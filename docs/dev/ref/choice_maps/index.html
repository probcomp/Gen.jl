<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choice Maps · Gen</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gen</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">Modeling Languages and APIs</span><ul><li><a class="tocitem" href="../gfi/">Generative Functions</a></li><li><a class="tocitem" href="../distributions/">Probability Distributions</a></li><li><a class="tocitem" href="../modeling/">Built-in Modeling Language</a></li><li><a class="tocitem" href="../combinators/">Generative Function Combinators</a></li><li class="is-active"><a class="tocitem" href>Choice Maps</a><ul class="internal"><li><a class="tocitem" href="#Mutable-Choice-Maps"><span>Mutable Choice Maps</span></a></li></ul></li><li><a class="tocitem" href="../selections/">Selections</a></li><li><a class="tocitem" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../trace_translators/">Trace Translators</a></li><li><a class="tocitem" href="../extending/">Extending Gen</a></li></ul></li><li><span class="tocitem">Standard Inference Library</span><ul><li><a class="tocitem" href="../importance/">Importance Sampling</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../pf/">Particle Filtering</a></li><li><a class="tocitem" href="../vi/">Variational Inference</a></li><li><a class="tocitem" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modeling Languages and APIs</a></li><li class="is-active"><a href>Choice Maps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Choice Maps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/choice_maps.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Choice-Maps"><a class="docs-heading-anchor" href="#Choice-Maps">Choice Maps</a><a id="Choice-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Choice-Maps" title="Permalink"></a></h1><p>Maps from the addresses of random choices to their values are stored in associative tree-structured data structures that have the following abstract type:</p><article class="docstring"><header><a class="docstring-binding" id="Gen.ChoiceMap" href="#Gen.ChoiceMap"><code>Gen.ChoiceMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ChoiceMap end</code></pre><p>Abstract type for maps from hierarchical addresses to values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L63-L67">source</a></section></article><p>Choice maps are constructed by users to express observations and/or constraints on the traces of generative functions. Choice maps are also returned by certain Gen inference methods, and are used internally by various Gen inference methods.</p><p>Choice maps provide the following methods:</p><article class="docstring"><header><a class="docstring-binding" id="Gen.has_value" href="#Gen.has_value"><code>Gen.has_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_value(choices::ChoiceMap, addr)</code></pre><p>Return true if there is a value at the given address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_value" href="#Gen.get_value"><code>Gen.get_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value = get_value(choices::ChoiceMap, addr)</code></pre><p>Return the value at the given address in the assignment, or throw a KeyError if no value exists. A syntactic sugar is <code>Base.getindex</code>:</p><pre><code class="nohighlight hljs">value = choices[addr]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_submap" href="#Gen.get_submap"><code>Gen.get_submap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">submap = get_submap(choices::ChoiceMap, addr)</code></pre><p>Return the sub-assignment containing all choices whose address is prefixed by addr.</p><p>It is an error if the assignment contains a value at the given address. If there are no choices whose address is prefixed by addr then return an <code>EmptyChoiceMap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_values_shallow" href="#Gen.get_values_shallow"><code>Gen.get_values_shallow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key_submap_iterable = get_values_shallow(choices::ChoiceMap)</code></pre><p>Return an iterator over tuples of the form <code>(key, value)</code> for each top-level key associated with a value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_submaps_shallow" href="#Gen.get_submaps_shallow"><code>Gen.get_submaps_shallow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key_submap_iterable = get_submaps_shallow(choices::ChoiceMap)</code></pre><p>Return an iterator over tuples of the form <code>(key, submap::ChoiceMap)</code> for each top-level key that has a non-empty sub-assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.to_array" href="#Gen.to_array"><code>Gen.to_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arr::Vector{T} = to_array(choices::ChoiceMap, ::Type{T}) where {T}</code></pre><p>Populate an array with values of choices in the given assignment.</p><p>It is an error if each of the values cannot be coerced into a value of the given type.</p><p><strong>Implementation</strong></p><p>To support <code>to_array</code>, a concrete subtype <code>T &lt;: ChoiceMap</code> should implement the following method:</p><pre><code class="nohighlight hljs">n::Int = _fill_array!(choices::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Populate <code>arr</code> with values from the given assignment, starting at <code>start_idx</code>, and return the number of elements in <code>arr</code> that were populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L154-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.from_array" href="#Gen.from_array"><code>Gen.from_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choices::ChoiceMap = from_array(proto_choices::ChoiceMap, arr::Vector)</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from the given array.</p><p>The order in which addresses are populated is determined by the prototype assignment. It is an error if the number of choices in the prototype assignment is not equal to the length the array.</p><p><strong>Implementation</strong></p><p>To support <code>from_array</code>, a concrete subtype <code>T &lt;: ChoiceMap</code> should implement the following method:</p><pre><code class="nohighlight hljs">(n::Int, choices::T) = _from_array(proto_choices::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from <code>arr</code>, starting at position <code>start_idx</code>, and the number of elements read from <code>arr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L197-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_selected" href="#Gen.get_selected"><code>Gen.get_selected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selected_choices = get_selected(choices::ChoiceMap, selection::Selection)</code></pre><p>Filter the choice map to include only choices in the given selection.</p><p>Returns a new choice map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L1016-L1022">source</a></section></article><p>Note that none of these methods mutate the choice map.</p><p>Choice maps also implement:</p><ul><li><p><code>Base.isempty</code>, which tests of there are no random choices in the choice map</p></li><li><p><code>Base.merge</code>, which takes two choice maps, and returns a new choice map containing all random choices in either choice map. It is an error if the choice maps both have values at the same address, or if one choice map has a value at an address that is the prefix of the address of a value in the other choice map.</p></li><li><p><code>==</code>, which tests if two choice maps have the same addresses and values at those addresses.</p></li></ul><h2 id="Mutable-Choice-Maps"><a class="docs-heading-anchor" href="#Mutable-Choice-Maps">Mutable Choice Maps</a><a id="Mutable-Choice-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-Choice-Maps" title="Permalink"></a></h2><p>A mutable choice map can be constructed with <a href="#Gen.choicemap"><code>choicemap</code></a>, and then populated:</p><pre><code class="language-julia hljs">choices = choicemap()
choices[:x] = true
choices[&quot;foo&quot;] = 1.25
choices[:y =&gt; 1 =&gt; :z] = -6.3</code></pre><p>There is also a constructor that takes initial (address, value) pairs:</p><pre><code class="language-julia hljs">choices = choicemap((:x, true), (&quot;foo&quot;, 1.25), (:y =&gt; 1 =&gt; :z, -6.3))</code></pre><article class="docstring"><header><a class="docstring-binding" id="Gen.choicemap" href="#Gen.choicemap"><code>Gen.choicemap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choices = choicemap()</code></pre><p>Construct an empty mutable choice map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L679-L683">source</a></section><section><div><pre><code class="nohighlight hljs">choices = choicemap(tuples...)</code></pre><p>Construct a mutable choice map initialized with given address, value tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L688-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.set_value!" href="#Gen.set_value!"><code>Gen.set_value!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_value!(choices::DynamicChoiceMap, addr, value)</code></pre><p>Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at this address to be deleted. It is an error if there is already a value present at some prefix of the given address.</p><p>The following syntactic sugar is provided:</p><pre><code class="nohighlight hljs">choices[addr] = value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L729-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.set_submap!" href="#Gen.set_submap!"><code>Gen.set_submap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_submap!(choices::DynamicChoiceMap, addr, submap::ChoiceMap)</code></pre><p>Replace the sub-assignment rooted at the given address with the given sub-assignment. Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at the given address to be deleted. It is an error if there is already a value present at some prefix of address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/cec0486aa3ef09825e93d964ea7d3aec2d2cbb20/src/choice_map.jl#L763-L771">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../combinators/">« Generative Function Combinators</a><a class="docs-footer-nextpage" href="../selections/">Selections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 25 January 2023 19:22">Wednesday 25 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
