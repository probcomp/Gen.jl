<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Combinators · Gen.jl</title><meta name="title" content="Combinators · Gen.jl"/><meta property="og:title" content="Combinators · Gen.jl"/><meta property="twitter:title" content="Combinators · Gen.jl"/><meta name="description" content="Documentation for Gen.jl."/><meta property="og:description" content="Documentation for Gen.jl."/><meta property="twitter:description" content="Documentation for Gen.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Gen.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Gen.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../../tutorials/modeling_in_gen/">Introduction to Modeling in Gen</a></li><li><a class="tocitem" href="../../../tutorials/mcmc_map/">Basics of MCMC and MAP Inference</a></li><li><a class="tocitem" href="../../../tutorials/enumerative/">Debugging Models with Enumeration</a></li><li><a class="tocitem" href="../../../tutorials/smc/">Object Tracking with SMC</a></li><li><a class="tocitem" href="../../../tutorials/vi/">Variational Inference in Gen</a></li><li><a class="tocitem" href="../../../tutorials/learning_gen_fns/">Learning Generative Functions</a></li><li><a class="tocitem" href="../../../tutorials/scaling_with_sml/">Speeding Up Inference with the SML</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">How-to Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../how_to/extending_gen/">Extending Gen</a></li><li><a class="tocitem" href="../../../how_to/custom_distributions/">Adding New Distributions</a></li><li><a class="tocitem" href="../../../how_to/custom_gen_fns/">Adding New Generative Functions</a></li><li><a class="tocitem" href="../../../how_to/custom_gradients/">Custom Gradients</a></li><li><a class="tocitem" href="../../../how_to/custom_incremental_computation/">Custom Incremental Computation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Core Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../core/gfi/">Generative Function Interface</a></li><li><a class="tocitem" href="../../core/choice_maps/">Choice Maps</a></li><li><a class="tocitem" href="../../core/selections/">Selections</a></li><li><a class="tocitem" href="../../core/change_hints/">Change Hints</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Modeling Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dml/">Built-In Modeling Language</a></li><li><a class="tocitem" href="../sml/">Static Modeling Language</a></li><li><a class="tocitem" href="../distributions/">Probability Distributions</a></li><li class="is-active"><a class="tocitem" href>Combinators</a><ul class="internal"><li><a class="tocitem" href="#Map-combinator"><span>Map combinator</span></a></li><li><a class="tocitem" href="#Unfold-combinator"><span>Unfold combinator</span></a></li><li><a class="tocitem" href="#Recurse-combinator"><span>Recurse combinator</span></a></li><li><a class="tocitem" href="#Switch-combinator"><span>Switch combinator</span></a></li><li><a class="tocitem" href="#Design-and-Implementation"><span>Design and Implementation</span></a></li></ul></li><li><a class="tocitem" href="../custom_gen_fns/">Custom Generative Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Inference Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inference/enumerative/">Enumerative Inference</a></li><li><a class="tocitem" href="../../inference/importance/">Importance Sampling</a></li><li><a class="tocitem" href="../../inference/mcmc/">Markov Chain Monte Carlo</a></li><li><a class="tocitem" href="../../inference/pf/">Particle Filtering &amp; SMC</a></li><li><a class="tocitem" href="../../inference/trace_translators/">Trace Translators</a></li><li><a class="tocitem" href="../../inference/parameter_optimization/">Parameter Optimization</a></li><li><a class="tocitem" href="../../inference/map/">MAP Optimization</a></li><li><a class="tocitem" href="../../inference/vi/">Variational Inference</a></li><li><a class="tocitem" href="../../inference/wake_sleep/">Wake-Sleep Learning</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Modeling Library</a></li><li class="is-active"><a href>Combinators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Combinators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/probcomp/Gen.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/modeling/combinators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="combinators"><a class="docs-heading-anchor" href="#combinators">Generative Function Combinators</a><a id="combinators-1"></a><a class="docs-heading-anchor-permalink" href="#combinators" title="Permalink"></a></h1><p>Generative function combinators are Julia functions that take one or more generative functions as input and return a new generative function. Generative function combinators are used to express patterns of repeated computation that appear frequently in generative models. Some generative function combinators are similar to higher order functions from functional programming languages. However, generative function combinators are not &#39;higher order generative functions&#39;, because they are not themselves generative functions (they are regular Julia functions).</p><h2 id="Map-combinator"><a class="docs-heading-anchor" href="#Map-combinator">Map combinator</a><a id="Map-combinator-1"></a><a class="docs-heading-anchor-permalink" href="#Map-combinator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.Map" href="#Gen.Map"><code>Gen.Map</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_fn = Map(kernel::GenerativeFunction)</code></pre><p>Return a new generative function that applies the kernel independently for a vector of inputs.</p><p>The returned generative function has one argument with type <code>Vector{X}</code> for each argument of the input generative function with type <code>X</code>. The length of each argument, which must be the same for each argument, determines the number of times the input generative function is called (N). Each call to the input function is made under address namespace i for i=1..N. The return value of the returned function has type <code>FunctionalCollections.PersistentVector{Y}</code> where <code>Y</code> is the type of the return value of the input function. The map combinator is similar to the &#39;map&#39; higher order function in functional programming, except that the map combinator returns a new generative function that must then be separately applied.</p><p>If <code>kernel</code> has optional trailing arguments, the corresponding <code>Vector</code> arguments can be omitted from calls to <code>Map(kernel)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/map/map.jl#L8-L20">source</a></section></article><p>In the schematic below, the kernel is denoted <span>$\mathcal{G}_{\mathrm{k}}$</span>.</p><div style="text-align:center">
    <img src="../../../assets/map_combinator.png" alt="schematic of map combinator" width="50%"/>
</div><p>For example, consider the following generative function, which makes one random choice at address <code>:z</code>:</p><pre><code class="language-julia hljs">@gen function foo(x1::Float64, x2::Float64)
    y = @trace(normal(x1 + x2, 1.0), :z)
    return y
end</code></pre><p>We apply the map combinator to produce a new generative function <code>bar</code>:</p><pre><code class="language-julia hljs">bar = Map(foo)</code></pre><p>We can then obtain a trace of <code>bar</code>:</p><pre><code class="language-julia hljs">(trace, _) = generate(bar, ([0.0, 0.5], [0.5, 1.0]))</code></pre><p>This causes <code>foo</code> to be invoked twice, once with arguments <code>(0.0, 0.5)</code> in address namespace <code>1</code> and once with arguments <code>(0.5, 1.0)</code> in address namespace <code>2</code>. If the resulting trace has random choices:</p><pre><code class="nohighlight hljs">│
├── 1
│   │
│   └── :z : -0.5757913836706721
│
└── 2
    │
    └── :z : 0.7357177113395333</code></pre><p>then the return value is:</p><pre><code class="nohighlight hljs">FunctionalCollections.PersistentVector{Any}[-0.575791, 0.735718]</code></pre><h2 id="Unfold-combinator"><a class="docs-heading-anchor" href="#Unfold-combinator">Unfold combinator</a><a id="Unfold-combinator-1"></a><a class="docs-heading-anchor-permalink" href="#Unfold-combinator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.Unfold" href="#Gen.Unfold"><code>Gen.Unfold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_fn = Unfold(kernel::GenerativeFunction)</code></pre><p>Return a new generative function that applies the kernel in sequence, passing the return value of one application as an input to the next.</p><p>The kernel accepts the following arguments:</p><ul><li><p>The first argument is the <code>Int</code> index indicating the position in the sequence (starting from 1).</p></li><li><p>The second argument is the <em>state</em>.</p></li><li><p>The kernel may have additional arguments after the state.</p></li></ul><p>The return type of the kernel must be the same type as the state.</p><p>The returned generative function accepts the following arguments:</p><ul><li><p>The number of times (N) to apply the kernel.</p></li><li><p>The initial state.</p></li><li><p>The rest of the arguments (not including the state) that will be passed to each kernel application.</p></li></ul><p>The return type of the returned generative function is <code>FunctionalCollections.PersistentVector{T}</code> where <code>T</code> is the return type of the kernel.</p><p>If <code>kernel</code> has optional trailing arguments, the corresponding arguments can be omitted from calls to <code>Unfold(kernel)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/unfold/unfold.jl#L5-L31">source</a></section></article><p>In the schematic below, the kernel is denoted <span>$\mathcal{G}_{\mathrm{k}}$</span>. The initial state is denoted <span>$y_0$</span>, the number of applications is <span>$n$</span>, and the remaining arguments to the kernel not including the state, are <span>$z$</span>.</p><div style="text-align:center">
    <img src="../../../assets/unfold_combinator.png" alt="schematic of unfold combinator" width="70%"/>
</div><p>For example, consider the following kernel, with state type <code>Bool</code>, which makes one random choice at address <code>:z</code>:</p><pre><code class="language-julia hljs">@gen function foo(t::Int, y_prev::Bool, z1::Float64, z2::Float64)
    y = @trace(bernoulli(y_prev ? z1 : z2), :y)
    return y
end</code></pre><p>We apply the map combinator to produce a new generative function <code>bar</code>:</p><pre><code class="language-julia hljs">bar = Unfold(foo)</code></pre><p>We can then obtain a trace of <code>bar</code>:</p><pre><code class="language-julia hljs">(trace, _) = generate(bar, (5, false, 0.05, 0.95))</code></pre><p>This causes <code>foo</code> to be invoked five times. The resulting trace may contain the following random choices:</p><pre><code class="nohighlight hljs">│
├── 1
│   │
│   └── :y : true
│
├── 2
│   │
│   └── :y : false
│
├── 3
│   │
│   └── :y : true
│
├── 4
│   │
│   └── :y : false
│
└── 5
    │
    └── :y : true
</code></pre><p>then the return value is:</p><pre><code class="nohighlight hljs">FunctionalCollections.PersistentVector{Any}[true, false, true, false, true]</code></pre><h2 id="Recurse-combinator"><a class="docs-heading-anchor" href="#Recurse-combinator">Recurse combinator</a><a id="Recurse-combinator-1"></a><a class="docs-heading-anchor-permalink" href="#Recurse-combinator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.Recurse" href="#Gen.Recurse"><code>Gen.Recurse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Recurse(production_kernel, aggregation_kernel, max_branch,
     ::Type{U}, ::Type{V}, ::Type{W})</code></pre><p>Constructor for recurse production and aggregation function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/recurse/recurse.jl#L113-L118">source</a></section></article><div style="text-align:center">
    <img src="../../../assets/recurse_combinator.png" alt="schematic of recurse combinatokr" width="70%"/>
</div><h2 id="Switch-combinator"><a class="docs-heading-anchor" href="#Switch-combinator">Switch combinator</a><a id="Switch-combinator-1"></a><a class="docs-heading-anchor-permalink" href="#Switch-combinator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.Switch" href="#Gen.Switch"><code>Gen.Switch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_fn = Switch(gen_fns::GenerativeFunction...)</code></pre><p>Returns a new generative function that accepts an argument tuple of type <code>Tuple{Int, ...}</code> where the first index indicates which branch to call.</p><pre><code class="nohighlight hljs">gen_fn = Switch(d::Dict{T, Int}, gen_fns::GenerativeFunction...) where T</code></pre><p>Returns a new generative function that accepts an argument tuple of type <code>Tuple{Int, ...}</code> or an argument tuple of type <code>Tuple{T, ...}</code> where the first index either indicates which branch to call, or indicates an index into <code>d</code> which maps to the selected branch. This form is meant for convenience - it allows the programmer to use <code>d</code> like if-else or case statements.</p><p><code>Switch</code> is designed to allow for the expression of patterns of if-else control flow. <code>gen_fns</code> must satisfy a few requirements:</p><ol><li>Each <code>gen_fn</code> in <code>gen_fns</code> must accept the same argument types.</li><li>Each <code>gen_fn</code> in <code>gen_fns</code> must return the same return type.</li></ol><p>Otherwise, each <code>gen_fn</code> can come from different modeling languages, possess different traces, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/switch/switch.jl#L41-L56">source</a></section></article><div style="text-align:center">
    <img src="../../../assets/switch_combinator.png" alt="schematic of switch combinator" width="100%"/>
</div><p>Consider the following constructions:</p><pre><code class="language-julia hljs">@gen function bang((grad)(x::Float64), (grad)(y::Float64))
    std::Float64 = 3.0
    z = @trace(normal(x + y, std), :z)
    return z
end

@gen function fuzz((grad)(x::Float64), (grad)(y::Float64))
    std::Float64 = 3.0
    z = @trace(normal(x + 2 * y, std), :z)
    return z
end

sc = Switch(bang, fuzz)</code></pre><p>This creates a new generative function <code>sc</code>. We can then obtain the trace of <code>sc</code>:</p><pre><code class="language-julia hljs">(trace, _) = simulate(sc, (2, 5.0, 3.0))</code></pre><p>The resulting trace contains the subtrace from the branch with index <code>2</code> - in this case, a call to <code>fuzz</code>:</p><pre><code class="nohighlight hljs">│
└── :z : 13.552870875213735</code></pre><h2 id="Design-and-Implementation"><a class="docs-heading-anchor" href="#Design-and-Implementation">Design and Implementation</a><a id="Design-and-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Design-and-Implementation" title="Permalink"></a></h2><p>Internally, the Combinators use custom trace types such as <a href="#Gen.VectorTrace"><code>Gen.VectorTrace</code></a>, and are implemented using the following methods:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.VectorTrace" href="#Gen.VectorTrace"><code>Gen.VectorTrace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorTrace &lt;: Trace</code></pre><p>U is the type of the subtrace, R is the return value type for the kernel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/vector.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.process_all_new!" href="#Gen.process_all_new!"><code>Gen.process_all_new!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Process all new applications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/map/generic_update.jl#L60-L62">source</a></section><section><div><p>Process all new applications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/unfold/generic_update.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.update_recurse_merge" href="#Gen.update_recurse_merge"><code>Gen.update_recurse_merge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_recurse_merge(prev_choices::ChoiceMap, choices::ChoiceMap)</code></pre><p>Returns choices that are in constraints, merged with all choices in the previous trace that do not have the same address as some choice in the constraints.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/switch/update.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gen.update_discard" href="#Gen.update_discard"><code>Gen.update_discard</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_discard(prev_choices::ChoiceMap, choices::ChoiceMap, new_choices::ChoiceMap)</code></pre><p>Returns choices from previous trace that:</p><ol><li>have an address which does not appear in the new trace.</li><li>have an address which does appear in the constraints.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/3f44183269baf671472b4497c3c00ee2d223d207/src/modeling_library/switch/update.jl#L57-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributions/">« Probability Distributions</a><a class="docs-footer-nextpage" href="../custom_gen_fns/">Custom Generative Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 6 September 2025 14:05">Saturday 6 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
