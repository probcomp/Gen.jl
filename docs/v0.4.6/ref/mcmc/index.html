<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Markov chain Monte Carlo · Gen</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gen</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">Modeling Languages and APIs</span><ul><li><a class="tocitem" href="../gfi/">Generative Functions</a></li><li><a class="tocitem" href="../distributions/">Probability Distributions</a></li><li><a class="tocitem" href="../modeling/">Built-in Modeling Language</a></li><li><a class="tocitem" href="../combinators/">Generative Function Combinators</a></li><li><a class="tocitem" href="../choice_maps/">Choice Maps</a></li><li><a class="tocitem" href="../selections/">Selections</a></li><li><a class="tocitem" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../trace_translators/">Trace Translators</a></li><li><a class="tocitem" href="../extending/">Extending Gen</a></li></ul></li><li><span class="tocitem">Standard Inference Library</span><ul><li><a class="tocitem" href="../importance/">Importance Sampling</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li class="is-active"><a class="tocitem" href>Markov chain Monte Carlo</a><ul class="internal"><li><a class="tocitem" href="#MCMC-in-Gen"><span>MCMC in Gen</span></a></li><li><a class="tocitem" href="#Built-in-Stationary-Kernels"><span>Built-in Stationary Kernels</span></a></li><li><a class="tocitem" href="#Enabling-Dynamic-Checks"><span>Enabling Dynamic Checks</span></a></li><li><a class="tocitem" href="#Composite-Kernel-DSL"><span>Composite Kernel DSL</span></a></li><li><a class="tocitem" href="#Involutive-MCMC"><span>Involutive MCMC</span></a></li><li><a class="tocitem" href="#Reverse-Kernels"><span>Reverse Kernels</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../pf/">Particle Filtering</a></li><li><a class="tocitem" href="../vi/">Variational Inference</a></li><li><a class="tocitem" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Inference Library</a></li><li class="is-active"><a href>Markov chain Monte Carlo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Markov chain Monte Carlo</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/mcmc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Markov-chain-Monte-Carlo-(MCMC)"><a class="docs-heading-anchor" href="#Markov-chain-Monte-Carlo-(MCMC)">Markov chain Monte Carlo (MCMC)</a><a id="Markov-chain-Monte-Carlo-(MCMC)-1"></a><a class="docs-heading-anchor-permalink" href="#Markov-chain-Monte-Carlo-(MCMC)" title="Permalink"></a></h1><p>Markov chain Monte Carlo (MCMC) is an approach to inference which involves initializing a hypothesis and then repeatedly sampling a new hypotheses given the previous hypothesis by making a change to the previous hypothesis. The function that samples the new hypothesis given the previous hypothesis is called the <strong>MCMC kernel</strong> (or `kernel&#39; for short). If we design the kernel appropriately, then the distribution of the hypotheses will converge to the conditional (i.e. posterior) distribution as we increase the number of times we apply the kernel.</p><p>Gen includes primitives for constructing MCMC kernels and composing them into MCMC algorithms. Although Gen encourages you to write MCMC algorithms that converge to the conditional distribution, Gen does not enforce this requirement. You may use Gen&#39;s MCMC primitives in other ways, including for stochastic optimization.</p><p>For background on MCMC see [1].</p><p>[1] Andrieu, Christophe, et al. &quot;An introduction to MCMC for machine learning.&quot; Machine learning 50.1-2 (2003): 5-43. <a href="https://www.cs.ubc.ca/~arnaud/andrieu_defreitas_doucet_jordan_intromontecarlomachinelearning.pdf">Link</a>.</p><h2 id="MCMC-in-Gen"><a class="docs-heading-anchor" href="#MCMC-in-Gen">MCMC in Gen</a><a id="MCMC-in-Gen-1"></a><a class="docs-heading-anchor-permalink" href="#MCMC-in-Gen" title="Permalink"></a></h2><p>Suppose we are doing inference in the following toy model:</p><pre><code class="language-julia hljs">@gen function model()
    x = @trace(bernoulli(0.5), :x) # a latent variable
    @trace(normal(x ? -1. : 1., 1.), :y) # the variable that will be observed
end</code></pre><p>To do MCMC, we first need to obtain an initial trace of the model. Recall that a trace encodes both the observed data and hypothesized values of latent variables. We can obtain an initial trace that encodes the observed data, and contains a randomly initialized hypothesis, using <a href="../gfi/#Gen.generate"><code>generate</code></a>, e.g.:</p><pre><code class="language-julia hljs">observations = choicemap((:y, 1.23))
trace, = generate(model, (), observations)</code></pre><p>Then, an MCMC algorithm is Gen is implemented simply by writing Julia <code>for</code> loop, which repeatedly applies a kernel, which is a regular Julia function:</p><pre><code class="language-julia hljs">for i=1:100
    trace = kernel(trace)
end</code></pre><h2 id="Built-in-Stationary-Kernels"><a class="docs-heading-anchor" href="#Built-in-Stationary-Kernels">Built-in Stationary Kernels</a><a id="Built-in-Stationary-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-Stationary-Kernels" title="Permalink"></a></h2><p>However, we don&#39;t expect to be able to use any function for <code>kernel</code> and expect to converge to the conditional distribution. To converge to the conditional distribution, the kernels must satisfy some properties. One of these properties is that the kernel is <strong>stationary</strong> with respect to the conditional distribution. Gen&#39;s inference library contains a number of functions for constructing stationary kernels:</p><ul><li><p><a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a> with alias <a href="#Gen.mh"><code>mh</code></a>, which has three variants with differing tradeoffs between ease-of-use and efficiency. The simplest variant simply requires you to select the set of random choices to be updated, without specifying how. The middle variant allows you to use custom proposals that encode problem-specific heuristics, or custom proposals based on neural networks that are trained via amortized inference. The most sophisticated variant allows you to specify any kernel in the <a href="https://people.maths.bris.ac.uk/~mapjg/papers/RJMCMCBka.pdf">reversible jump MCMC</a> framework.</p></li><li><p><a href="#Gen.mala"><code>mala</code></a>, which performs a Metropolis Adjusted Langevin algorithm update on a set of selected random choices.</p></li><li><p><a href="#Gen.hmc"><code>hmc</code></a>, which performs a Hamiltonian Monte Carlo update on a set of selected random choices.</p></li><li><p><a href="#Gen.elliptical_slice"><code>elliptical_slice</code></a>, which performs an elliptical slice sampling update on a selected multivariate normal random choice.</p></li></ul><p>For example, here is an MCMC inference algorithm that uses <a href="#Gen.mh"><code>mh</code></a>:</p><pre><code class="language-julia hljs">function do_inference(y, num_iters)
    trace, = generate(model, (), choicemap((:y, y)))
    xs = Float64[]
    for i=1:num_iters
        trace, = mh(trace, select(:x))
        push!(xs, trace[:x])
    end
    xs
end</code></pre><p>Note that each of the kernel functions listed above stationary with respect to the joint distribution on traces of the model, but may not be stationary with respect to the intended conditional distribution, which is determined by the set of addresses that consititute the observed data. If a kernel modifies the values of any of the observed data, then the kernel is not stationary with respect to the conditional distribution. Therefore, you should <strong>ensure that your MCMC kernels never propose to the addresses of the observations</strong>.</p><p>Note that stationarity with respect to the conditional distribution alone is not sufficient for a kernel to converge to the posterior with infinite iterations. Other requirements include that the chain is <strong>irreducible</strong> (it is possible to get from any state to any other state in a finite number of steps), and <strong>aperiodicity</strong>, which is a more complex requirement that is satisfied when kernels have some probability of staying in the same state, which most of the primitive kernels above satisfy. We refer interested readers to [1] for additional details on MCMC convergence.</p><h2 id="Enabling-Dynamic-Checks"><a class="docs-heading-anchor" href="#Enabling-Dynamic-Checks">Enabling Dynamic Checks</a><a id="Enabling-Dynamic-Checks-1"></a><a class="docs-heading-anchor-permalink" href="#Enabling-Dynamic-Checks" title="Permalink"></a></h2><p>Gen does not statically guarantee that kernels (either ones built-in or composed with the <a href="#Composite-Kernel-DSL">Composite Kernel DSL</a>) are stationary. However, you can enable dynamic checks that will detect common bugs that break stationarity. To enable the dynamic checks we pass a keyword argument beyond those of the kernel itself:</p><pre><code class="language-julia hljs">new_trace = k(trace, 2, check=true)</code></pre><p>Note that these checks aim to detect when a kernel is not stationary with respect to the model&#39;s <strong>joint</strong> distribution. To add an additional dynamic check for violation of stationarity with respect to the <em>conditional</em> distribution (conditioned on observations), we pass in an additional keyword argument containing a choice map with the observations:</p><pre><code class="language-julia hljs">new_trace = k(traced, 2, check=true, observations=choicemap((:y, 1.2)))</code></pre><p>If <code>check</code> is set to <code>false</code>, then the observation check is not performed.</p><h2 id="Composite-Kernel-DSL"><a class="docs-heading-anchor" href="#Composite-Kernel-DSL">Composite Kernel DSL</a><a id="Composite-Kernel-DSL-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Kernel-DSL" title="Permalink"></a></h2><p>You can freely compose the primitive kernels listed above into more complex kernels. Common types of composition including e.g. cycling through multiple kernels, randomly choosing a kernel to apply, and choosing which kernel to apply based on the current state. However, not all such compositions of stationary kernels will result in kernels that are themselves stationary.</p><p>Gen&#39;s <strong>Composite Kernel DSL</strong> is an embedded inference DSL that allows for more safe composition of MCMC kernels, by formalizing properties of the compositions that are sufficient for stationarity, encouraging compositions with these properties, and dynamically checking for violation of these properties. Although the DSL does not <em>guarantee</em> stationarity of the composite kernels, its dynamic checks do catch common cases of non-stationary kernels. The dynamic checks can be enabled and disabled as needed (e.g. enabled during testing and prototyping and disabled during deployment for higher performance).</p><p>The DSL consists of a macro – <a href="#Gen.@kern"><code>@kern</code></a> for composing stationary kernels from primitive stationary kernels and composite stationary kernels, and two additional macros: –- <a href="#Gen.@pkern"><code>@pkern</code></a> for declaring Julia functions to be custom primitive stationary kernels, and <a href="#Gen.@rkern"><code>@rkern</code></a> for declaring the reversal of a custom primitive kernel (these two macros are advanced features not necessary for standard MCMC algorithms).</p><h3 id="Composing-Stationary-Kernels"><a class="docs-heading-anchor" href="#Composing-Stationary-Kernels">Composing Stationary Kernels</a><a id="Composing-Stationary-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Composing-Stationary-Kernels" title="Permalink"></a></h3><p>The <a href="#Gen.@kern"><code>@kern</code></a> macro defines a composite MCMC kernel in a restricted DSL that is based on Julia&#39;s own function definition syntax.</p><p>Suppose we are doing inference in the following model:</p><pre><code class="language-julia hljs">@gen function model()
    n = @trace(geometric(0.5), :n)
    total = 0.
    for i=1:n
        total += @trace(normal(0, 1), (:x, i))
    end
    @trace(normal(total, 1.), :y)
    total
end</code></pre><p>Here is an example composite kernel for MCMC in this model:</p><pre><code class="language-julia hljs">@kern function my_kernel(trace)
    
    # cycle through the x&#39;s and do a random walk update on each one
    for i in 1:trace[:n]
        trace ~ mh(trace, random_walk_proposal, (i,))
    end

    # repeatedly pick a random x and do a random walk update on it
    if trace[:n] &gt; 0
        for rep in 1:10
            let i ~ uniform_discrete(1, trace[:n])
                trace ~ mh(trace, random_walk_proposal, (i,))
            end
        end
    end

    # remove the last x, or add a new one, a random number of times
    let n_add_remove_reps ~ uniform_discrete(0, max_n_add_remove)
        for rep in 1:n_add_remove_reps
            trace ~ mh(trace, add_remove_proposal, (), add_remove_involution)
        end
    end
end</code></pre><p>In the DSL, the first argument (<code>trace</code> in this case) represents the trace on which the kernel is acting. the kernel may have additional arguments. The code inside the body can read from the trace (e.g. <code>trace[:n]</code> reads the value of the random choice <code>:n</code>). Finally, the return value of the composite kernel is automatically set to the trace. NOTE: It is not permitted to assign to the trace variable, except with <code>~</code> expressions. Also note that stationary kernels, when treated as Julia functions, return a tuple, where the first element is the trace and the remaining arguments are metadata. When applying these kernels with <code>~</code> syntax within the DSL, it is not necessary to unpack the tuple (the metadata is ignored automatically).</p><p>The language constructs supported by this DSL are:</p><p><strong>Applying a stationary kernel.</strong> To apply a kernel, the syntax <code>trace ~ k(trace, args..)</code> is used. Note that the <code>check</code> and <code>observations</code> keyword arguments (see <a href="#Enabling-Dynamic-Checks">Enabling Dynamic Checks</a>) should not be used here; they will be added automatically.</p><p><strong>For loops.</strong> The range of the for loop may be a deterministic function of the trace (as in <code>trace[:n]</code> above). The range must be <em>invariant</em> under all possible executions of the body of the for loop. For example, the random walk based kernel embedded in the for loop in our example above cannot modify the value of the random choice <code>:n</code> in the trace.</p><p><strong>If-end expressions</strong> The predicate condition may be a deterministic function of the trace, but it also must be invariant (i.e. remain true) under all possible executions of the body.</p><p><strong>Deterministic let expressions.</strong> We can use <code>let x = value .. end</code> to bind values to a variable, but the expression on the right-hand-side must be deterministic function of its free variables, its value must be invariant under all possible executions of the body.</p><p><strong>Stochastic let expressions.</strong> We can use <code>let x ~ dist(args...) .. end</code> to sample a stochastic value and bind to a variable, but the expression on the right-hand-side must be the application of a Gen <a href="ref/@ref"><code>Distribution</code></a> to arguments, and the distribution and its arguments must be invariant under all possible executions of the body.</p><h3 id="Declaring-primitive-kernels-for-use-in-composite-kernels"><a class="docs-heading-anchor" href="#Declaring-primitive-kernels-for-use-in-composite-kernels">Declaring primitive kernels for use in composite kernels</a><a id="Declaring-primitive-kernels-for-use-in-composite-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Declaring-primitive-kernels-for-use-in-composite-kernels" title="Permalink"></a></h3><p>Note that all calls to built-in kernels like <a href="#Gen.mh"><code>mh</code></a> should be stationary, but that users are also free to declare their own arbitrary code as stationary. The <a href="#Gen.@pkern"><code>@pkern</code></a> macro declares a Julia function as a stationary MCMC kernel, for use with the MCMC Kernel DSL. The following custom primitive kernel permutes the random variables using random permutation generated from outside of Gen: </p><pre><code class="language-julia hljs">@pkern function permute_move(trace; check=false, observations=EmptyChoiceMap())
    perm = Random.randperm(trace[:n])
    constraints = choicemap()
    for (i, j) in enumerate(perm)
        constraints[(:x, i)] = trace[(:x, j)]
        constraints[(:x, j)] = trace[(:x, i)]
    end
    trace, = update(trace, (), (), constraints)
    metadata = nothing
    trace, metadata
end</code></pre><p>The first argument to the function should be the trace, and the function must have keyword arguments <code>check</code> and <code>observations</code> (see <a href="#Enabling-Dynamic-Checks">Enabling Dynamic Checks</a>). The return value should be a tuple where the first element is the new trace (and any remaining elements are optional metadata).</p><p><strong>Primitive kernels are Julia functions.</strong> Note that although we will be invoking these kernels within <a href="#Gen.@kern"><code>@kern</code></a> functions, these kernels can still be called like a regular Julia function.</p><pre><code class="language-julia hljs">new_trace = permute_move(trace, 2)</code></pre><p>Indeed, they are just regular Julia functions, but with some extra information attached so that the composite kernel DSL knows they have been declared as stationary kernels.</p><h2 id="Involutive-MCMC"><a class="docs-heading-anchor" href="#Involutive-MCMC">Involutive MCMC</a><a id="Involutive-MCMC-1"></a><a class="docs-heading-anchor-permalink" href="#Involutive-MCMC" title="Permalink"></a></h2><p>Gen&#39;s most flexible variant of <a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a>, called <strong>Involutive MCMC</strong>, allows users to specify any MCMC kernel in the reversible jump MCMC (RJMCMC) framework [2]. Involution MCMC allows you to express a broad class of custom MCMC kernels that are not expressible using the other, simpler variants of Metropolis-Hastings supported by Gen. These kernels are particularly useful for inferring the structure (e.g. control flow) of a model.</p><p>[2] Green, Peter J. &quot;Reversible jump Markov chain Monte Carlo computation and Bayesian model determination.&quot; Biometrika 82.4 (1995): 711-732. <a href="https://academic.oup.com/biomet/article-abstract/82/4/711/252058">Link</a></p><p>An involutive MCMC kernel in Gen takes as input a previous trace of the model (whose choice map we will denote by <span>$t$</span>), and performs three phases to obtain a new trace of the model:</p><ul><li><p>First, it traces the execution of a <strong>proposal</strong>, which is an auxiliary generative function that takes the previous trace of the model as its first argument. Mathematically, we will denote the choice map associated with the trace of the proposal by <span>$u$</span>. The proposal can of course be defined using the <a href="ref/@ref">Built-In Modeling Languages</a>, just like the model itself. However, unlike many other uses of proposals in Gen, these proposals <em>can make random choices at addresses that the model does not</em>.</p></li><li><p>Next, it takes the tuple <span>$(t, u)$</span> and passes it into an <strong>involution</strong> (denoted mathematically by <span>$h$</span>), which is a function that returns a new tuple <span>$(t&#39;, u&#39;)$</span>, where <span>$t&#39;$</span> is the choice map for a new proposed trace of the model, and <span>$u&#39;$</span> are random choices for a new trace of the proposal. The defining property of the involution is that <em>it is invertible</em>, and <em>it is its own inverse</em>; i.e. <span>$(t, u) = h(h(t, u))$</span>. Intuitively, <span>$u&#39;$</span> is a description of a way that the proposal could be reversed, taking <span>$t&#39;$</span> to <span>$t$</span>.</p></li><li><p>Finally, it computes an acceptance probability, which involves computing certain derivatives associated with the involution, and stochastically accepts or rejects the proposed model trace according to this probability. The involution is typically defined using the <a href="../trace_translators/#Trace-Transform-DSL">Trace Transform DSL</a>, in which case the acceptance probability calculation is fully automated.</p></li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Consider the following generative model of two pieces of observed data, at addresses <code>:y1</code> and <code>:y2</code>.</p><pre><code class="language-julia hljs">@gen function model()
    if ({:z} ~ bernoulli(0.5))
        m1 = ({:m1} ~ gamma(1, 1))
        m2 = ({:m2} ~ gamma(1, 1))
    else
        m = ({:m} ~ gamma(1, 1))
        (m1, m2) = (m, m)
    end
    {:y1} ~ normal(m1, 0.1)
    {:y2} ~ normal(m2, 0.1)
end</code></pre><p>Because this model has stochastic control flow, it represents two distinct structural hypotheses about how the observed data could have been generated: If <code>:z</code> is <code>true</code> then we enter the first branch, and we hypothesize that the two data points were generated from separate means, sampled at addresses <code>:m1</code> and <code>:m2</code>. If <code>:z</code> is <code>false</code> then we enter the second branch, and we hypohesize that there is a single mean that explains both data points, sampled at address <code>:m</code>.</p><p>We want to construct an MCMC kernel that is able to transition between these two distinct structural hypotheses. We could construct such a kernel with the simpler &#39;selection&#39; variant of Metropolis-Hastings, by selecting the address <code>:z</code>, e.g.:</p><pre><code class="language-julia hljs">select_mh_structure_kernel(trace) = mh(trace, select(:z))[1]</code></pre><p>Sometimes, this kernel would propose to change the value of <code>:z</code>. We could interleave this kernel with another kernel that does inference over the mean random choices, without changing the structure, e.g.:</p><pre><code class="language-julia hljs">@gen function fixed_structure_proposal(trace)
    if trace[:z]
        {:m1} ~ normal(trace[:m1], 0.1)
        {:m2} ~ normal(trace[:m2], 0.1)
    else
        {:m} ~ normal(trace[:m], 0.1)
    end
end

fixed_structure_kernel(trace) = mh(trace, fixed_structure_proposal, ())[1]</code></pre><p>Combining these together, and applying to particular data and with a specific initial hypotheses:</p><pre><code class="language-julia hljs">(y1, y2) = (1.0, 1.3)
trace, = generate(model, (), choicemap((:y1, y1), (:y2, y2), (:z, false), (:m, 1.2)))
for iter=1:100
    trace = select_mh_structure_kernel(trace)
    trace = fixed_structure_kernel(trace)
end</code></pre><p>However, this algorithm will not be very efficient, because the internal proposal used by the selection variant of MH is not specialized to the model. In particular, when switching from the model with a single mean to the model with two means, the values of the new addresses <code>:m1</code> and <code>:m2</code> will be proposed from the prior distribution. This is wasteful, since if we have inferred an accurate value for <code>:m</code>, we expect the values for <code>:m1</code> and <code>:m2</code> to be near this value. The same is true when proposing a structure change in the opposite direction. That means it will take many more steps to get an accurate estimate of the posterior probability distribution on the two structures.</p><p>We would like to use inferred values for <code>:m1</code> and <code>:m2</code> to inform our proposal for the value of <code>:m</code>. For example, we could take the geometric mean:</p><pre><code class="language-julia hljs">m = sqrt(m1 * m2)</code></pre><p>However, there are many combinations of <code>m1</code> and <code>m2</code> that have the same geometric mean. In other words, the geometric mean is not <em>invertible</em>. However, if we return the additional degree of freedom alongside the geometric mean (<code>u</code>), then we do have an invertible function:</p><pre><code class="language-julia hljs">function merge_means(m1, m2)
    m = sqrt(m1 * m2)
    u = m1 / (m1 + m2)
    (m, u)
end</code></pre><p>The inverse function is:</p><pre><code class="language-julia hljs">function split_mean(m, u)
    m1 = m * sqrt((u / (1 - u)))
    m2 = m * sqrt(((1 - u) / u))
    (m1, m2)
end</code></pre><p>We use these two functions to construct an involution, and we use this involution with <a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a> to construct an MCMC kernel that we call a &#39;split/merge&#39; kernel, because it either splits a parameter value, or merges two parameter values. The proposal is responsible for generating the extra degree of freedom when splitting:</p><pre><code class="language-julia hljs">@gen function split_merge_proposal(trace)
    if trace[:z]
        # currently two segments, switch to one
    else
        # currently one segment, switch to two
        {:u} ~ uniform_continuous(0, 1)
    end
end</code></pre><p>Finally, we write the involution itself, using the <a href="../trace_translators/#Trace-Transform-DSL">Trace Transform DSL</a>:</p><pre><code class="language-julia hljs">@transform split_merge_involution (model_in, aux_in) to (model_out, aux_out) begin
    if @read(model_in[:z], :discrete)

        # currently two means, switch to one
        @write(model_out[:z], false, :discrete)
        m1 = @read(model_in[:m1], :continuous)
        m2 = @read(model_in[:m2], :continuous)
        (m, u) = merge_means(m1, m2)
        @write(model_out[:m], m, :continuous)
        @write(aux_out[:u], u, :continuous)
    else

        # currently one mean, switch to two
        @write(model_out[:z], true, :discrete)
        m = @read(model_in[:m], :continuous)
        u = @read(aux_in[:u], :continuous)
        (m1, m2) = split_mean(m, u)
        @write(model_out[:m1], m1, :continuous)
        @write(model_out[:m2], m2, :continuous)
    end
end</code></pre><p>The body of this function reads values from <span>$(t, u)$</span> at specific addresses and writes values to <span>$(t&#39;, u&#39;)$</span> at specific addresses, where <span>$t$</span> and <span>$t&#39;$</span> are called &#39;model&#39; choice maps, and <span>$u$</span> and <span>$u&#39;$</span> are called &#39;proposal&#39; choice maps. Note that the inputs and outputs of this function are <strong>not</strong> represented in the same way as arguments or return values of regular Julia functions –- they are implicit and can only be read from and written to, respectively, using a set of special macros (listed below). You should convince yourself that this function is invertible and its own inverse.</p><p>Finally, we compose a structure-changing MCMC kernel using this involution:</p><pre><code class="language-julia hljs">split_merge_kernel(trace) = mh(trace, split_merge_proposal, (), split_merge_involution)[1]</code></pre><p>We then compose this move with the fixed structure move, and run it on the observed data:</p><pre><code class="language-julia hljs">(y1, y2) = (1.0, 1.3)
trace, = generate(model, (), choicemap((:y1, y1), (:y2, y2), (:z, false), (:m, 1.)))
for iter=1:100
    trace = split_merge_kernel(trace)
    trace = fixed_structure_kernel(trace)
end</code></pre><p>We can then compare the results to the results from the Markov chain that used the selection-based structure-changing kernel:</p><p><img src="../images/rjmcmc.png" alt="rjmcmc plot"/></p><p>We see that if we initialize the Markov chains from the same state with a single mean (<code>:z</code> is <code>false</code>) then the selection-based kernel fails to accept any moves to the two-mean structure within 100 iterations, whereas the split-merge kernel transitions back and forth many times, If we repeated the selection-based kernel for enough iterations, it would eventually transition back and forth at the same rate as the split-merge. The split-merge kernel gives a much more efficient inference algorithm for estimating the posterior probability on the two structures.</p><h2 id="Reverse-Kernels"><a class="docs-heading-anchor" href="#Reverse-Kernels">Reverse Kernels</a><a id="Reverse-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse-Kernels" title="Permalink"></a></h2><p>The <strong>reversal</strong> of a stationary MCMC kernel with distribution <span>$k_1(t&#39;; t)$</span>, for model with distribution <span>$p(t; x)$</span>, is another MCMC kernel with distribution:</p><p class="math-container">\[k_2(t; t&#39;) := \frac{p(t; x)}{p(t&#39;; x)} k_1(t&#39;; t)\]</p><p>For custom primitive kernels declared with <a href="#Gen.@pkern"><code>@pkern</code></a>, users can declare the reversal kernel with the <a href="#Gen.@rkern"><code>@rkern</code></a> macro:</p><pre><code class="language-julia hljs">@rkern k1 : k2</code></pre><p>This also assigns <code>k1</code> as the reversal of <code>k2</code>. The composite kernel DSL automatically generates the reversal kernel for composite kernels, and built-in stationary kernels like <a href="#Gen.mh"><code>mh</code></a>. The reversal of a kernel (primitive or composite) can be obtained with <a href="#Gen.reversal"><code>reversal</code></a>.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gen.metropolis_hastings" href="#Gen.metropolis_hastings"><code>Gen.metropolis_hastings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, accepted) = metropolis_hastings(
    trace, selection::Selection;
    check=false, observations=EmptyChoiceMap())</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for the selected addresses from the internal proposal (often using ancestral sampling), returning the new trace (which is equal to the previous trace if the move was not accepted) and a Bool indicating whether the move was accepted or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mh.jl#L7-L13">source</a></section><section><div><pre><code class="nohighlight hljs">(new_trace, accepted) = metropolis_hastings(
    trace, proposal::GenerativeFunction, proposal_args::Tuple;
    check=false, observations=EmptyChoiceMap())</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for some subset of random choices in the given trace using the given proposal generative function, returning the new trace (which is equal to the previous trace if the move was not accepted) and a Bool indicating whether the move was accepted or not.</p><p>The proposal generative function should take as its first argument the current trace of the model, and remaining arguments <code>proposal_args</code>. If the proposal modifies addresses that determine the control flow in the model, values must be provided by the proposal for any addresses that are newly sampled by the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mh.jl#L31-L40">source</a></section><section><div><pre><code class="nohighlight hljs">(new_trace, accepted) = metropolis_hastings(
    trace, proposal::GenerativeFunction, proposal_args::Tuple,
    involution::Union{TraceTransformDSLProgram,Function};
    check=false, observations=EmptyChoiceMap())</code></pre><p>Perform a generalized (reversible jump) Metropolis-Hastings update based on an involution (bijection that is its own inverse) on a space of choice maps, returning the new trace (which is equal to the previous trace if the move was not accepted) and a Bool indicating whether the move was accepted or not.</p><p>Most users will want to construct <code>involution</code> using the <a href="../trace_translators/#Trace-Transform-DSL">Trace Transform DSL</a> with the <a href="../trace_translators/#Gen.@transform"><code>@transform</code></a> macro, but for more user control it is also possible to provide a Julia function for <code>involution</code>, that has the following signature:</p><pre><code class="nohighlight hljs">(new_trace, bwd_choices::ChoiceMap, weight) = involution(trace::Trace, fwd_choices::ChoiceMap, fwd_retval, fwd_args::Tuple)</code></pre><p>The generative function <code>proposal</code> is executed on arguments <code>(trace, proposal_args...)</code>, producing a choice map <code>fwd_choices</code> and return value <code>fwd_ret</code>. For each value of model arguments (contained in <code>trace</code>) and <code>proposal_args</code>, the <code>involution</code> function applies an involution that maps the tuple <code>(get_choices(trace), fwd_choices)</code> to the tuple <code>(get_choices(new_trace), bwd_choices)</code>. Note that <code>fwd_ret</code> is a deterministic function of <code>fwd_choices</code> and <code>proposal_args</code>. When only discrete random choices are used, the <code>weight</code> must be equal to <code>get_score(new_trace) - get_score(trace)</code>.</p><p>When continuous random choices are used, the <code>weight</code> returned by the involution must include an additive correction term that is the determinant of the the Jacobian of the bijection on the continuous random choices that is obtained by currying the involution on the discrete random choices (this correction term is automatically computed if the involution is constructed using the <a href="../trace_translators/#Trace-Transform-DSL">Trace Transform DSL</a>). NOTE: The Jacobian matrix of the bijection on the continuous random choices must be full-rank (i.e. nonzero determinant). The <code>check</code> keyword argument to the involution can be used to enable or disable any dynamic correctness checks that the involution performs; for successful executions, <code>check</code> does not alter the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mh.jl#L64-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.mh" href="#Gen.mh"><code>Gen.mh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, accepted) = mh(trace, selection::Selection; ..)
(new_trace, accepted) = mh(trace, proposal::GenerativeFunction, proposal_args::Tuple; ..)
(new_trace, accepted) = mh(trace, proposal::GenerativeFunction, proposal_args::Tuple, involution; ..)</code></pre><p>Alias for <a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a>. Perform a Metropolis-Hastings update on the given trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mh.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.mala" href="#Gen.mala"><code>Gen.mala</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, accepted) = mala(
    trace, selection::Selection, tau::Real;
    check=false, observations=EmptyChoiceMap())</code></pre><p>Apply a Metropolis-Adjusted Langevin Algorithm (MALA) update.</p><p><a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm">Reference URL</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mala.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.hmc" href="#Gen.hmc"><code>Gen.hmc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, accepted) = hmc(
    trace, selection::Selection; L=10, eps=0.1,
    check=false, observations=EmptyChoiceMap())</code></pre><p>Apply a Hamiltonian Monte Carlo (HMC) update that proposes new values for the selected addresses, returning the new trace (which is equal to the previous trace if the move was not accepted) and a <code>Bool</code> indicating whether the move was accepted or not.</p><p>Hamilton&#39;s equations are numerically integrated using leapfrog integration with step size <code>eps</code> for <code>L</code> steps. See equations (5.18)-(5.20) of Neal (2011).</p><p><strong>References</strong></p><p>Neal, Radford M. (2011), &quot;MCMC Using Hamiltonian Dynamics&quot;, Handbook of Markov Chain Monte Carlo, pp. 113-162. URL: http://www.mcmchandbook.net/HandbookChapter5.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/hmc.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.elliptical_slice" href="#Gen.elliptical_slice"><code>Gen.elliptical_slice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_trace = elliptical_slice(
    trace, addr, mu, cov;
    check=false, observations=EmptyChoiceMap())</code></pre><p>Apply an elliptical slice sampling update to a given random choice with a multivariate normal prior.</p><p>Also takes the mean vector and covariance matrix of the prior.</p><p><a href="http://proceedings.mlr.press/v9/murray10a/murray10a.pdf">Reference URL</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/elliptical_slice.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.@pkern" href="#Gen.@pkern"><code>Gen.@pkern</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pkern function k(trace, args...; 
                  check=false, observations=EmptyChoiceMap())
    ...
    return trace
end</code></pre><p>Declare a Julia function as a primitive stationary kernel.</p><p>The first argument of the function should be a trace, and the return value of the function should be a <code>(trace, metadata)</code> where <code>metadata</code> is user-provided (but could be useful information, like the result of an accept-reject decision.</p><p>There should be keyword arguments check and observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/kernel_dsl.jl#L21-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.@kern" href="#Gen.@kern"><code>Gen.@kern</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@kern function k(trace, args...)
    ...
end</code></pre><p>Construct a composite MCMC kernel.</p><p>The resulting object is a Julia function that is annotated as a composite MCMC kernel, and can be called as a Julia function or applied within other composite kernels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/kernel_dsl.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.@rkern" href="#Gen.@rkern"><code>Gen.@rkern</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rkern k1 : k2</code></pre><p>Declare that two primitive stationary kernels are reversals of one another.</p><p>The two kernels must have the same argument type signatures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/kernel_dsl.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.reversal" href="#Gen.reversal"><code>Gen.reversal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">k2 = reversal(k1)</code></pre><p>Return the reversal kernel for a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/kernel_dsl.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.involutive_mcmc" href="#Gen.involutive_mcmc"><code>Gen.involutive_mcmc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, accepted) = involutive_mcmc(trace, proposal::GenerativeFunction, proposal_args::Tuple, involution; ..)</code></pre><p>Alias for the involutive form of <a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/inference/mh.jl#L109-L113">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../map/">« MAP Optimization</a><a class="docs-footer-nextpage" href="../map/">MAP Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 September 2023 20:26">Wednesday 20 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
