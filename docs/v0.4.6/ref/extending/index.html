<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Gen · Gen</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gen</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">Modeling Languages and APIs</span><ul><li><a class="tocitem" href="../gfi/">Generative Functions</a></li><li><a class="tocitem" href="../distributions/">Probability Distributions</a></li><li><a class="tocitem" href="../modeling/">Built-in Modeling Language</a></li><li><a class="tocitem" href="../combinators/">Generative Function Combinators</a></li><li><a class="tocitem" href="../choice_maps/">Choice Maps</a></li><li><a class="tocitem" href="../selections/">Selections</a></li><li><a class="tocitem" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../trace_translators/">Trace Translators</a></li><li class="is-active"><a class="tocitem" href>Extending Gen</a><ul class="internal"><li><a class="tocitem" href="#Custom-gradients"><span>Custom gradients</span></a></li><li><a class="tocitem" href="#Custom-incremental-computation"><span>Custom incremental computation</span></a></li><li><a class="tocitem" href="#custom_distributions"><span>Custom distributions</span></a></li><li><a class="tocitem" href="#Custom-generative-functions"><span>Custom generative functions</span></a></li><li><a class="tocitem" href="#Custom-modeling-languages"><span>Custom modeling languages</span></a></li></ul></li></ul></li><li><span class="tocitem">Standard Inference Library</span><ul><li><a class="tocitem" href="../importance/">Importance Sampling</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../pf/">Particle Filtering</a></li><li><a class="tocitem" href="../vi/">Variational Inference</a></li><li><a class="tocitem" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modeling Languages and APIs</a></li><li class="is-active"><a href>Extending Gen</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extending Gen</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/extending.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Extending-Gen"><a class="docs-heading-anchor" href="#Extending-Gen">Extending Gen</a><a id="Extending-Gen-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-Gen" title="Permalink"></a></h1><p>Gen is designed for extensibility. To implement behaviors that are not directly supported by the existing modeling languages, users can implement `black-box&#39; generative functions directly, without using built-in modeling language. These generative functions can then be invoked by generative functions defined using the built-in modeling language. This includes several special cases:</p><ul><li><p>Extending Gen with custom gradient computations</p></li><li><p>Extending Gen with custom incremental computation of return values</p></li><li><p>Extending Gen with new modeling languages.</p></li></ul><h2 id="Custom-gradients"><a class="docs-heading-anchor" href="#Custom-gradients">Custom gradients</a><a id="Custom-gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-gradients" title="Permalink"></a></h2><p>To add a custom gradient for a differentiable deterministic computation, define a concrete subtype of <a href="#Gen.CustomGradientGF"><code>CustomGradientGF</code></a> with the following methods:</p><ul><li><p><a href="#Gen.apply"><code>apply</code></a></p></li><li><p><a href="#Gen.gradient"><code>gradient</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>For example:</p><pre><code class="language-julia hljs">struct MyPlus &lt;: CustomGradientGF{Float64} end

Gen.apply(::MyPlus, args) = args[1] + args[2]
Gen.gradient(::MyPlus, args, retval, retgrad) = (retgrad, retgrad)
Gen.has_argument_grads(::MyPlus) = (true, true)</code></pre><article class="docstring"><header><a class="docstring-binding" id="Gen.CustomGradientGF" href="#Gen.CustomGradientGF"><code>Gen.CustomGradientGF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomGradientGF{T}</code></pre><p>Abstract type for a generative function with a custom gradient computation, and default behaviors for all other generative function interface methods.</p><p><code>T</code> is the type of the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.apply" href="#Gen.apply"><code>Gen.apply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retval = apply(gen_fn::CustomGradientGF, args)</code></pre><p>Apply the function to the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.gradient" href="#Gen.gradient"><code>Gen.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arg_grads = gradient(gen_fn::CustomDetermGF, args, retval, retgrad)</code></pre><p>Return the gradient tuple with respect to the arguments, where <code>nothing</code> is for argument(s) whose gradient is not available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L165-L169">source</a></section></article><h2 id="Custom-incremental-computation"><a class="docs-heading-anchor" href="#Custom-incremental-computation">Custom incremental computation</a><a id="Custom-incremental-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-incremental-computation" title="Permalink"></a></h2><p>Iterative inference techniques like Markov chain Monte Carlo involve repeatedly updating the execution traces of generative models. In some cases, the output of a deterministic computation within the model can be incrementally computed during each of these updates, instead of being computed from scratch.</p><p>To add a custom incremental computation for a deterministic computation, define a concrete subtype of <a href="#Gen.CustomUpdateGF"><code>CustomUpdateGF</code></a> with the following methods:</p><ul><li><p><a href="#Gen.apply_with_state"><code>apply_with_state</code></a></p></li><li><p><a href="#Gen.update_with_state"><code>update_with_state</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>The second type parameter of <code>CustomUpdateGF</code> is the type of the state that may be used internally to facilitate incremental computation within <code>update_with_state</code>.</p><p>For example, we can implement a function for computing the sum of a vector that efficiently computes the new sum when a small fraction of the vector elements change:</p><pre><code class="language-julia hljs">struct MyState
    prev_arr::Vector{Float64}
    sum::Float64
end

struct MySum &lt;: CustomUpdateGF{Float64,MyState} end

function Gen.apply_with_state(::MySum, args)
    arr = args[1]
    s = sum(arr)
    state = MyState(arr, s)
    (s, state)
end

function Gen.update_with_state(::MySum, state, args, argdiffs::Tuple{VectorDiff})
    arr = args[1]
    prev_sum = state.sum
    retval = prev_sum
    for i in keys(argdiffs[1].updated)
        retval += (arr[i] - state.prev_arr[i])
    end
    prev_length = length(state.prev_arr)
    new_length = length(arr)
    for i=prev_length+1:new_length
        retval += arr[i]
    end
    for i=new_length+1:prev_length
        retval -= arr[i]
    end
    state = MyState(arr, retval)
    (state, retval, UnknownChange())
end

Gen.num_args(::MySum) = 1</code></pre><article class="docstring"><header><a class="docstring-binding" id="Gen.CustomUpdateGF" href="#Gen.CustomUpdateGF"><code>Gen.CustomUpdateGF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomUpdateGF{T,S}</code></pre><p>Abstract type for a generative function with a custom update computation, and default behaviors for all other generative function interface methods.</p><p><code>T</code> is the type of the return value and <code>S</code> is the type of state used internally for incremental computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.apply_with_state" href="#Gen.apply_with_state"><code>Gen.apply_with_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retval, state = apply_with_state(gen_fn::CustomDetermGF, args)</code></pre><p>Execute the generative function and return the return value and the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.update_with_state" href="#Gen.update_with_state"><code>Gen.update_with_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">state, retval, retdiff = update_with_state(gen_fn::CustomDetermGF, state, args, argdiffs)</code></pre><p>Update the arguments to the generative function and return new return value and state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/custom_determ.jl#L47-L51">source</a></section></article><h2 id="custom_distributions"><a class="docs-heading-anchor" href="#custom_distributions">Custom distributions</a><a id="custom_distributions-1"></a><a class="docs-heading-anchor-permalink" href="#custom_distributions" title="Permalink"></a></h2><p>Users can extend Gen with new probability distributions, which can then be used to make random choices within generative functions. Simple transformations of existing distributions can be created using the <a href="../distributions/#dist_dsl"><code>@dist</code> DSL</a>. For arbitrary distributions, including distributions that cannot be expressed in the <code>@dist</code> DSL, users can define a custom distribution by implementing Gen&#39;s Distribution interface directly, as defined below.</p><p>Probability distributions are singleton types whose supertype is <code>Distribution{T}</code>, where <code>T</code> indicates the data type of the random sample.</p><pre><code class="language-julia hljs">abstract type Distribution{T} end</code></pre><p>A new Distribution type must implement the following methods:</p><ul><li><p><a href="#Gen.random"><code>random</code></a></p></li><li><p><a href="#Gen.logpdf"><code>logpdf</code></a></p></li><li><p><a href="#Gen.has_output_grad"><code>has_output_grad</code></a></p></li><li><p><a href="#Gen.logpdf_grad"><code>logpdf_grad</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>By convention, distributions have a global constant lower-case name for the singleton value. For example:</p><pre><code class="language-julia hljs">struct Bernoulli &lt;: Distribution{Bool} end
const bernoulli = Bernoulli()</code></pre><p>Distribution values should also be callable, which is a syntactic sugar with the same behavior of calling <code>random</code>:</p><pre><code class="language-julia hljs">bernoulli(0.5) # identical to random(bernoulli, 0.5) and random(Bernoulli(), 0.5)</code></pre><article class="docstring"><header><a class="docstring-binding" id="Gen.random" href="#Gen.random"><code>Gen.random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">val::T = random(dist::Distribution{T}, args...)</code></pre><p>Sample a random choice from the given distribution with the given arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/modeling_library.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.logpdf" href="#Gen.logpdf"><code>Gen.logpdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lpdf = logpdf(dist::Distribution{T}, value::T, args...)</code></pre><p>Evaluate the log probability (density) of the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/modeling_library.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.has_output_grad" href="#Gen.has_output_grad"><code>Gen.has_output_grad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has::Bool = has_output_grad(dist::Distribution)</code></pre><p>Return true of the gradient if the distribution computes the gradient of the logpdf with respect to the value of the random choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/modeling_library.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.logpdf_grad" href="#Gen.logpdf_grad"><code>Gen.logpdf_grad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grads::Tuple = logpdf_grad(dist::Distribution{T}, value::T, args...)</code></pre><p>Compute the gradient of the logpdf with respect to the value, and each of the arguments.</p><p>If <code>has_output_grad</code> returns false, then the first element of the returned tuple is <code>nothing</code>. Otherwise, the first element of the tuple is the gradient with respect to the value. If the return value of <code>has_argument_grads</code> has a false value for at position <code>i</code>, then the <code>i+1</code>th element of the returned tuple has value <code>nothing</code>. Otherwise, this element contains the gradient with respect to the <code>i</code>th argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/modeling_library/modeling_library.jl#L31-L40">source</a></section></article><h2 id="Custom-generative-functions"><a class="docs-heading-anchor" href="#Custom-generative-functions">Custom generative functions</a><a id="Custom-generative-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-generative-functions" title="Permalink"></a></h2><p>We recommend the following steps for implementing a new type of generative function, and also looking at the implementation for the <a href="../modeling/#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a> type as an example.</p><h5 id="Define-a-trace-data-type"><a class="docs-heading-anchor" href="#Define-a-trace-data-type">Define a trace data type</a><a id="Define-a-trace-data-type-1"></a><a class="docs-heading-anchor-permalink" href="#Define-a-trace-data-type" title="Permalink"></a></h5><pre><code class="language-julia hljs">struct MyTraceType &lt;: Trace
    ..
end</code></pre><h5 id="Decide-the-return-type-for-the-generative-function"><a class="docs-heading-anchor" href="#Decide-the-return-type-for-the-generative-function">Decide the return type for the generative function</a><a id="Decide-the-return-type-for-the-generative-function-1"></a><a class="docs-heading-anchor-permalink" href="#Decide-the-return-type-for-the-generative-function" title="Permalink"></a></h5><p>Suppose our return type is <code>Vector{Float64}</code>.</p><h5 id="Define-a-data-type-for-your-generative-function"><a class="docs-heading-anchor" href="#Define-a-data-type-for-your-generative-function">Define a data type for your generative function</a><a id="Define-a-data-type-for-your-generative-function-1"></a><a class="docs-heading-anchor-permalink" href="#Define-a-data-type-for-your-generative-function" title="Permalink"></a></h5><p>This should be a subtype of <a href="../gfi/#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>, with the appropriate type parameters.</p><pre><code class="language-julia hljs">struct MyGenerativeFunction &lt;: GenerativeFunction{Vector{Float64},MyTraceType}
..
end</code></pre><p>Note that your generative function may not need to have any fields. You can create a constructor for it, e.g.:</p><pre><code class="nohighlight hljs">function MyGenerativeFunction(...)
..
end</code></pre><h5 id="Decide-what-the-arguments-to-a-generative-function-should-be"><a class="docs-heading-anchor" href="#Decide-what-the-arguments-to-a-generative-function-should-be">Decide what the arguments to a generative function should be</a><a id="Decide-what-the-arguments-to-a-generative-function-should-be-1"></a><a class="docs-heading-anchor-permalink" href="#Decide-what-the-arguments-to-a-generative-function-should-be" title="Permalink"></a></h5><p>For example, our generative functions might take two arguments, <code>a</code> (of type <code>Int</code>) and <code>b</code> (of type <code>Float64</code>). Then, the argument tuple passed to e.g. <a href="../gfi/#Gen.generate"><code>generate</code></a> will have two elements.</p><p>NOTE: Be careful to distinguish between arguments to the generative function itself, and arguments to the constructor of the generative function. For example, if you have a generative function type that is parametrized by, for example, modeling DSL code, this DSL code would be a parameter of the generative function constructor.</p><h5 id="Decide-what-the-traced-random-choices-(if-any)-will-be"><a class="docs-heading-anchor" href="#Decide-what-the-traced-random-choices-(if-any)-will-be">Decide what the traced random choices (if any) will be</a><a id="Decide-what-the-traced-random-choices-(if-any)-will-be-1"></a><a class="docs-heading-anchor-permalink" href="#Decide-what-the-traced-random-choices-(if-any)-will-be" title="Permalink"></a></h5><p>Remember that each random choice is assigned a unique address in (possibly) hierarchical address space. You are free to design this address space as you wish, although you should document it for users of your generative function type.</p><h5 id="Implement-methods-of-the-Generative-Function-Interface"><a class="docs-heading-anchor" href="#Implement-methods-of-the-Generative-Function-Interface">Implement methods of the Generative Function Interface</a><a id="Implement-methods-of-the-Generative-Function-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-methods-of-the-Generative-Function-Interface" title="Permalink"></a></h5><p>At minimum, you need to implement the following methods:</p><ul><li><p><a href="../gfi/#Gen.simulate"><code>simulate</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li><li><p><a href="../gfi/#Gen.accepts_output_grad"><code>accepts_output_grad</code></a></p></li><li><p><a href="../gfi/#Gen.get_args"><code>get_args</code></a></p></li><li><p><a href="../gfi/#Gen.get_retval"><code>get_retval</code></a></p></li><li><p><a href="../gfi/#Gen.get_choices"><code>get_choices</code></a></p></li><li><p><a href="../gfi/#Gen.get_score"><code>get_score</code></a></p></li><li><p><a href="../gfi/#Gen.get_gen_fn"><code>get_gen_fn</code></a></p></li><li><p><a href="../gfi/#Gen.project"><code>project</code></a></p></li></ul><p>If you want to use the generative function within models, you should implement:</p><ul><li><a href="../gfi/#Gen.generate"><code>generate</code></a></li></ul><p>If you want to use MCMC on models that call your generative function, then implement:</p><ul><li><p><a href="../gfi/#Gen.update"><code>update</code></a></p></li><li><p><a href="../gfi/#Gen.regenerate"><code>regenerate</code></a></p></li></ul><p>If you want to use gradient-based inference techniques on models that call your generative function, then implement:</p><ul><li><p><a href="../gfi/#Gen.choice_gradients"><code>choice_gradients</code></a></p></li><li><p><a href="../gfi/#Gen.update"><code>update</code></a></p></li></ul><p>If your generative function has trainable parameters, then implement:</p><ul><li><a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a></li></ul><h2 id="Custom-modeling-languages"><a class="docs-heading-anchor" href="#Custom-modeling-languages">Custom modeling languages</a><a id="Custom-modeling-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-modeling-languages" title="Permalink"></a></h2><p>Gen can be extended with new modeling languages by implementing new generative function types, and constructors for these types that take models as input. This typically requires implementing the entire generative function interface, and is advanced usage of Gen.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../trace_translators/">« Trace Translators</a><a class="docs-footer-nextpage" href="../importance/">Importance Sampling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 September 2023 20:26">Wednesday 20 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
