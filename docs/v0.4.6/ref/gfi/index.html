<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Functions · Gen</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gen</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/">Tutorials</a></li><li><span class="tocitem">Modeling Languages and APIs</span><ul><li class="is-active"><a class="tocitem" href>Generative Functions</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Mathematical-concepts"><span>Mathematical concepts</span></a></li><li><a class="tocitem" href="#Traces"><span>Traces</span></a></li><li><a class="tocitem" href="#Updating-traces"><span>Updating traces</span></a></li><li><a class="tocitem" href="#Differentiable-programming"><span>Differentiable programming</span></a></li><li><a class="tocitem" href="#Generative-function-interface"><span>Generative function interface</span></a></li></ul></li><li><a class="tocitem" href="../distributions/">Probability Distributions</a></li><li><a class="tocitem" href="../modeling/">Built-in Modeling Language</a></li><li><a class="tocitem" href="../combinators/">Generative Function Combinators</a></li><li><a class="tocitem" href="../choice_maps/">Choice Maps</a></li><li><a class="tocitem" href="../selections/">Selections</a></li><li><a class="tocitem" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../trace_translators/">Trace Translators</a></li><li><a class="tocitem" href="../extending/">Extending Gen</a></li></ul></li><li><span class="tocitem">Standard Inference Library</span><ul><li><a class="tocitem" href="../importance/">Importance Sampling</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="tocitem" href="../map/">MAP Optimization</a></li><li><a class="tocitem" href="../pf/">Particle Filtering</a></li><li><a class="tocitem" href="../vi/">Variational Inference</a></li><li><a class="tocitem" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="tocitem" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modeling Languages and APIs</a></li><li class="is-active"><a href>Generative Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generative Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/gfi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Generative-Functions"><a class="docs-heading-anchor" href="#Generative-Functions">Generative Functions</a><a id="Generative-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generative-Functions" title="Permalink"></a></h1><p>One of the core abstractions in Gen is the <strong>generative function</strong>. Generative functions are used to represent a variety of different types of probabilistic computations including generative models, inference models, custom proposal distributions, and variational approximations.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Generative functions are represented by the following abstact type:</p><article class="docstring"><header><a class="docstring-binding" id="Gen.GenerativeFunction" href="#Gen.GenerativeFunction"><code>Gen.GenerativeFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GenerativeFunction{T,U &lt;: Trace}</code></pre><p>Abstract type for a generative function with return value type T and trace type U.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L98-L102">source</a></section></article><p>There are various kinds of generative functions, which are represented by concrete subtypes of <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>. For example, the <a href="../modeling/#Built-in-Modeling-Language">Built-in Modeling Language</a> allows generative functions to be constructed using Julia function definition syntax:</p><pre><code class="language-julia hljs">@gen function foo(a, b=0)
    if @trace(bernoulli(0.5), :z)
        return a + b + 1
    else
        return a + b
    end
end</code></pre><p>Users can also extend Gen by implementing their own <a href="ref/@ref">Custom generative function types</a>, which can be new modeling languages, or just specialized optimized implementations of a fragment of a specific model.</p><p>Generative functions behave like Julia functions in some respects. For example, we can call a generative function <code>foo</code> on arguments and get an output value using regular Julia call syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; foo(2, 4)
7</code></pre><p>However, generative functions are distinct from Julia functions because they support additional behaviors, described in the remainder of this section.</p><h2 id="Mathematical-concepts"><a class="docs-heading-anchor" href="#Mathematical-concepts">Mathematical concepts</a><a id="Mathematical-concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-concepts" title="Permalink"></a></h2><p>Generative functions represent computations that accept some arguments, may use randomness internally, return an output, and cannot mutate externally observable state. We represent the randomness used during an execution of a generative function as a <strong>choice map</strong> from unique <strong>addresses</strong> to values of random choices, denoted <span>$t : A \to V$</span> where <span>$A$</span> is a finite (but not a priori bounded) address set and <span>$V$</span> is a set of possible values that random choices can take. In this section, we assume that random choices are discrete to simplify notation. We say that two choice maps <span>$t$</span> and <span>$s$</span> <strong>agree</strong> if they assign the same value for any address that is in both of their domains.</p><p>Generative functions may also use <strong>non-addressable randomness</strong>, which is not included in the map <span>$t$</span>. We denote non-addressable randomness by <span>$r$</span>. Untraced randomness is useful for example, when calling black box Julia code that implements a randomized algorithm.</p><p>The observable behavior of every generative function is defined by the following mathematical objects:</p><h3 id="Input-type"><a class="docs-heading-anchor" href="#Input-type">Input type</a><a id="Input-type-1"></a><a class="docs-heading-anchor-permalink" href="#Input-type" title="Permalink"></a></h3><p>The set of valid argument tuples to the function, denoted <span>$X$</span>.</p><h3 id="Probability-distribution-family"><a class="docs-heading-anchor" href="#Probability-distribution-family">Probability distribution family</a><a id="Probability-distribution-family-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-distribution-family" title="Permalink"></a></h3><p>A family of probability distributions <span>$p(t, r; x)$</span> on maps <span>$t$</span> from random choice addresses to their values, and non-addressable randomness <span>$r$</span>, indexed by arguments <span>$x$</span>, for all <span>$x \in X$</span>. Note that the distribution must be normalized:</p><p class="math-container">\[\sum_{t, r} p(t, r; x) = 1 \;\; \mbox{for all} \;\; x \in X\]</p><p>This corresponds to a requirement that the function terminate with probabability 1 for all valid arguments. We use <span>$p(t; x)$</span> to denote the marginal distribution on the map <span>$t$</span>:</p><p class="math-container">\[p(t; x) := \sum_{r} p(t, r; x)\]</p><p>And we denote the conditional distribution on non-addressable randomness <span>$r$</span>, given the map <span>$t$</span>, as:</p><p class="math-container">\[p(r | t; x) := p(t, r; x) / p(t; x)\]</p><h3 id="Return-value-function"><a class="docs-heading-anchor" href="#Return-value-function">Return value function</a><a id="Return-value-function-1"></a><a class="docs-heading-anchor-permalink" href="#Return-value-function" title="Permalink"></a></h3><p>A (deterministic) function <span>$f$</span> that maps the tuple <span>$(x, t)$</span> of the arguments and the choice map to the return value of the function (which we denote by <span>$y$</span>). Note that the return value cannot depend on the non-addressable randomness.</p><h3 id="Auxiliary-state"><a class="docs-heading-anchor" href="#Auxiliary-state">Auxiliary state</a><a id="Auxiliary-state-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary-state" title="Permalink"></a></h3><p>Generative functions may expose additional <strong>auxiliary state</strong> associated with an execution, besides the choice map and the return value. This auxiliary state is a function <span>$z = h(x, t, r)$</span> of the arguments, choice map, and non-addressable randomness. Like the choice map, the auxiliary state is indexed by addresses. We require that the addresses of auxiliary state are disjoint from the addresses in the choice map. Note that when a generative function is called within a model, the auxiliary state is not available to the caller. It is typically used by inference programs, for logging and for caching the results of deterministic computations that would otherwise need to be reconstructed.</p><h3 id="Internal-proposal-distribution-family"><a class="docs-heading-anchor" href="#Internal-proposal-distribution-family">Internal proposal distribution family</a><a id="Internal-proposal-distribution-family-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-proposal-distribution-family" title="Permalink"></a></h3><p>A family of probability distributions <span>$q(t; x, u)$</span> on maps <span>$t$</span> from random choice addresses to their values, indexed by tuples <span>$(x, u)$</span> where <span>$u$</span> is a map from random choice addresses to values, and where <span>$x$</span> are the arguments to the function. It must satisfy the following conditions:</p><p class="math-container">\[\sum_{t} q(t; x, u) = 1 \;\; \mbox{for all} \;\; x \in X, u\]</p><p class="math-container">\[p(t; x) &gt; 0 \mbox{ if and only if } q(t; x, u) &gt; 0 \mbox{ for all } u \mbox{ where } u \mbox{ and } t \mbox{ agree }\]</p><p class="math-container">\[q(t; x, u) &gt; 0 \mbox{ implies that } u \mbox{ and } t \mbox{ agree }.\]</p><p>There is also a family of probability distributions <span>$q(r; x, t)$</span> on non-addressable randomness, that satisfies:</p><p class="math-container">\[q(r; x, t) &gt; 0 \mbox{ if and only if } p(r | t, x) &gt; 0\]</p><h2 id="Traces"><a class="docs-heading-anchor" href="#Traces">Traces</a><a id="Traces-1"></a><a class="docs-heading-anchor-permalink" href="#Traces" title="Permalink"></a></h2><p>An <strong>execution trace</strong> (or just <em>trace</em>) is a record of an execution of a generative function. Traces are the primary data structures manipulated by Gen inference programs. There are various methods for producing, updating, and inspecting traces. Traces contain:</p><ul><li><p>the arguments to the generative function</p></li><li><p>the choice map</p></li><li><p>the return value</p></li><li><p>auxiliary state</p></li><li><p>other implementation-specific state that is not exposed to the caller or user of the generative function, but is used internally to facilitate e.g. incremental updates to executions and automatic differentiation</p></li><li><p>any necessary record of the non-addressable randomness</p></li></ul><p>Different concrete types of generative functions use different data structures and different Julia types for their traces, but traces are subtypes of <a href="#Gen.Trace"><code>Trace</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Gen.Trace" href="#Gen.Trace"><code>Gen.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Trace</code></pre><p>Abstract type for a trace of a generative function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L5-L9">source</a></section></article><p>The concrete trace type that a generative function uses is the second type parameter of the <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a> abstract type. For example, the trace type of <a href="../modeling/#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a> is <code>DynamicDSLTrace</code>.</p><p>A generative function can be executed to produce a trace of the execution using <a href="#Gen.simulate"><code>simulate</code></a>:</p><pre><code class="language-julia hljs">trace = simulate(foo, (a, b))</code></pre><p>A traced execution that satisfies constraints on the choice map can be generated using <a href="#Gen.generate"><code>generate</code></a>:</p><pre><code class="language-julia hljs">trace, weight = generate(foo, (a, b), choicemap((:z, false)))</code></pre><p>There are various methods for inspecting traces, including:</p><ul><li><p><a href="#Gen.get_args"><code>get_args</code></a> (returns the arguments to the function)</p></li><li><p><a href="#Gen.get_retval"><code>get_retval</code></a> (returns the return value of the function)</p></li><li><p><a href="#Gen.get_choices"><code>get_choices</code></a> (returns the choice map)</p></li><li><p><a href="#Gen.get_score"><code>get_score</code></a> (returns the log probability that the random choices took the values they did)</p></li><li><p><a href="#Gen.get_gen_fn"><code>get_gen_fn</code></a> (returns a reference to the generative function)</p></li></ul><p>You can also access the values in the choice map and the auxiliary state of the trace by passing the address to <a href="#Base.getindex"><code>Base.getindex</code></a>. For example, to retrieve the value of random choice at address <code>:z</code>:</p><pre><code class="language-julia hljs">z = trace[:z]</code></pre><p>When a generative function has default values specified for trailing arguments, those arguments can be left out when calling <a href="#Gen.simulate"><code>simulate</code></a>, <a href="#Gen.generate"><code>generate</code></a>, and other functions provided by the generative function interface. The default values will automatically be filled in:</p><pre><code class="language-julia hljs">julia&gt; trace = simulate(foo, (2,));
julia&gt; get_args(trace)
(2, 0)</code></pre><h2 id="Updating-traces"><a class="docs-heading-anchor" href="#Updating-traces">Updating traces</a><a id="Updating-traces-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-traces" title="Permalink"></a></h2><p>It is often important to incrementally modify the trace of a generative function (e.g. within MCMC, numerical optimization, sequential Monte Carlo, etc.). In Gen, traces are <strong>functional data structures</strong>, meaning they can be treated as immutable values. There are several methods that take a trace of a generative function as input and return a new trace of the generative function based on adjustments to the execution history of the function. We will illustrate these methods using the following generative function:</p><pre><code class="language-julia hljs">@gen function bar()
    val = @trace(bernoulli(0.3), :a)
    if @trace(bernoulli(0.4), :b)
        val = @trace(bernoulli(0.6), :c) &amp;&amp; val
    else
        val = @trace(bernoulli(0.1), :d) &amp;&amp; val
    end
    val = @trace(bernoulli(0.7), :e) &amp;&amp; val
    return val
end</code></pre><p>Suppose we have a trace (<code>trace</code>) of <code>bar</code> with initial choices:</p><pre><code class="nohighlight hljs">│
├── :a : false
│
├── :b : true
│
├── :c : false
│
└── :e : true</code></pre><p>Note that address <code>:d</code> is not present because the branch in which <code>:d</code> is sampled was not taken because random choice <code>:b</code> had value <code>true</code>.</p><h3 id="Update"><a class="docs-heading-anchor" href="#Update">Update</a><a id="Update-1"></a><a class="docs-heading-anchor-permalink" href="#Update" title="Permalink"></a></h3><p>The <a href="#Gen.update"><code>update</code></a> method takes a trace and generates an adjusted trace that is consistent with given changes to the arguments to the function, and changes to the values of random choices made.</p><p><strong>Example.</strong> Suppose we run <a href="#Gen.update"><code>update</code></a> on the example <code>trace</code>, with the following constraints:</p><pre><code class="nohighlight hljs">│
├── :b : false
│
└── :d : true</code></pre><pre><code class="language-julia hljs">constraints = choicemap((:b, false), (:d, true))
(new_trace, w, _, discard) = update(trace, (), (), constraints)</code></pre><p>Then <code>get_choices(new_trace)</code> will be:</p><pre><code class="nohighlight hljs">│
├── :a : false
│
├── :b : false
│
├── :d : true
│
└── :e : true</code></pre><p>and <code>discard</code> will be:</p><pre><code class="nohighlight hljs">│
├── :b : true
│
└── :c : false</code></pre><p>Note that the discard contains both the previous values of addresses that were overwritten, and the values for addresses that were in the previous trace but are no longer in the new trace. The weight (<code>w</code>) is computed as:</p><p class="math-container">\[p(t; x) = 0.7 × 0.4 × 0.4 × 0.7 = 0.0784\\
p(t&#39;; x&#39;) = 0.7 × 0.6 × 0.1 × 0.7 = 0.0294\\
w = \log p(t&#39;; x&#39;)/p(t; x) = \log 0.0294/0.0784 = \log 0.375\]</p><p><strong>Example.</strong> Suppose we run <a href="#Gen.update"><code>update</code></a> on the example <code>trace</code>, with the following constraints, which <em>do not</em> contain a value for <code>:d</code>:</p><pre><code class="nohighlight hljs">│
└── :b : false</code></pre><pre><code class="language-julia hljs">constraints = choicemap((:b, false))
(new_trace, w, _, discard) = update(trace, (), (), constraints)</code></pre><p>Then <code>get_choices(new_trace)</code> will be:</p><pre><code class="nohighlight hljs">│
├── :a : false
│
├── :b : false
│
├── :d : true
│
└── :e : true</code></pre><p>with probability 0.1, or:</p><pre><code class="nohighlight hljs">│
├── :a : false
│
├── :b : false
│
├── :d : false
│
└── :e : true</code></pre><p>with probability 0.9. Also, <code>discard</code> will be:</p><pre><code class="nohighlight hljs">│
├── :b : true
│
└── :c : false</code></pre><p>If the former case occurs and <code>:d</code> is assigned to <code>true</code>, then the weight (<code>w</code>) is computed as:</p><p class="math-container">\[p(t; x) = 0.7 × 0.4 × 0.4 × 0.7 = 0.0784\\
p(t&#39;; x&#39;) = 0.7 × 0.6 × 0.1 × 0.7 = 0.0294\\
q(t&#39;; x&#39;, t + u) = 0.1\\
w = \log p(t&#39;; x&#39;)/(p(t; x) q(t&#39;; x&#39;, t + u)) = \log 0.0294/(0.0784 \cdot 0.1) = \log (3.75)\]</p><h3 id="Regenerate"><a class="docs-heading-anchor" href="#Regenerate">Regenerate</a><a id="Regenerate-1"></a><a class="docs-heading-anchor-permalink" href="#Regenerate" title="Permalink"></a></h3><p>The <a href="#Gen.regenerate"><code>regenerate</code></a> method takes a trace and generates an adjusted trace that is consistent with a change to the arguments to the function, and also generates new values for selected random choices.</p><p><strong>Example.</strong> Suppose we run <a href="#Gen.regenerate"><code>regenerate</code></a> on the example <code>trace</code>, with selection <code>:a</code> and <code>:b</code>:</p><pre><code class="language-julia hljs">(new_trace, w, _) = regenerate(trace, (), (), select(:a, :b))</code></pre><p>Then, a new value for <code>:a</code> will be sampled from <code>bernoulli(0.3)</code>, and a new value for <code>:b</code> will be sampled from <code>bernoulli(0.4)</code>. If the new value for <code>:b</code> is <code>true</code>, then the previous value for <code>:c</code> (<code>false</code>) will be retained. If the new value for <code>:b</code> is <code>false</code>, then a new value for <code>:d</code> will be sampled from <code>bernoulli(0.7)</code>. The previous value for <code>:c</code> will always be retained. Suppose the new value for <code>:a</code> is <code>true</code>, and the new value for <code>:b</code> is <code>true</code>. Then <code>get_choices(new_trace)</code> will be:</p><pre><code class="nohighlight hljs">│
├── :a : true
│
├── :b : true
│
├── :c : false
│
└── :e : true</code></pre><p>The weight (<code>w</code>) is <span>$\log 1 = 0$</span>.</p><h3 id="Argdiffs"><a class="docs-heading-anchor" href="#Argdiffs">Argdiffs</a><a id="Argdiffs-1"></a><a class="docs-heading-anchor-permalink" href="#Argdiffs" title="Permalink"></a></h3><p>In addition to the input trace, and other arguments that indicate how to adjust the trace, each of these methods also accepts an <strong>args</strong> argument and an <strong>argdiffs</strong> argument, both of which are tuples. The args argument contains the new arguments to the generative function, which may differ from the previous arguments to the generative function (which can be retrieved by applying <a href="#Gen.get_args"><code>get_args</code></a> to the previous trace). In many cases, the adjustment to the execution specified by the other arguments to these methods is &#39;small&#39; and only affects certain parts of the computation. Therefore, it is often possible to generate the new trace and the appropriate log probability ratios required for these methods without revisiting every state of the computation of the generative function.</p><p>To enable this, the argdiffs argument provides additional information about the <em>difference</em> between each of the previous arguments to the generative function, and its new argument value. This argdiff information permits the implementation of the update method to avoid inspecting the entire argument data structure to identify which parts were updated. Note that the correctness of the argdiff is in general not verified by Gen–-passing incorrect argdiff information may result in incorrect behavior.</p><p>The trace update methods for all generative functions above should accept at least the following types of argdiffs:</p><article class="docstring"><header><a class="docstring-binding" id="Gen.NoChange" href="#Gen.NoChange"><code>Gen.NoChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoChange</code></pre><p>The value did not change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/diff.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.UnknownChange" href="#Gen.UnknownChange"><code>Gen.UnknownChange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnknownChange</code></pre><p>No information is provided about the change to the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/diff.jl#L34-L38">source</a></section></article><p>Generative functions may also be able to process more specialized diff data types for each of their arguments, that allow more precise information about the different to be supplied.</p><h3 id="Retdiffs"><a class="docs-heading-anchor" href="#Retdiffs">Retdiffs</a><a id="Retdiffs-1"></a><a class="docs-heading-anchor-permalink" href="#Retdiffs" title="Permalink"></a></h3><p>To enable generative functions that invoke other functions to efficiently make use of incremental computation, the trace update methods of generative functions also return a <strong>retdiff</strong> value, which provides information about the difference in the return value of the previous trace an the return value of the new trace.</p><h2 id="Differentiable-programming"><a class="docs-heading-anchor" href="#Differentiable-programming">Differentiable programming</a><a id="Differentiable-programming-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiable-programming" title="Permalink"></a></h2><p>The trace of a generative function may support computation of gradients of its log probability with respect to some subset of (i) its arguments, (ii) values of random choice, and (iii) any of its <strong>trainable parameters</strong> (see below).</p><p>To compute gradients with respect to the arguments as well as certain selected random choices, use:</p><ul><li><a href="#Gen.choice_gradients"><code>choice_gradients</code></a></li></ul><p>To compute gradients with respect to the arguments, and to increment a stateful gradient accumulator for the trainable parameters of the generative function, use:</p><ul><li><a href="#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a></li></ul><p>A generative function statically reports whether or not it is able to compute gradients with respect to each of its arguments, through the function <a href="#Gen.has_argument_grads"><code>has_argument_grads</code></a>.</p><h3 id="Trainable-parameters"><a class="docs-heading-anchor" href="#Trainable-parameters">Trainable parameters</a><a id="Trainable-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Trainable-parameters" title="Permalink"></a></h3><p>The <strong>trainable parameters</strong> of a generative function are (unlike arguments and random choices) <em>state</em> of the generative function itself, and are not contained in the trace. Generative functions that have trainable parameters maintain <em>gradient accumulators</em> for these parameters, which get incremented by the gradient induced by the given trace by a call to <a href="#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a>. Users then use these accumulated gradients to update to the values of the trainable parameters.</p><h3 id="Return-value-gradient"><a class="docs-heading-anchor" href="#Return-value-gradient">Return value gradient</a><a id="Return-value-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Return-value-gradient" title="Permalink"></a></h3><p>The set of elements (either arguments, random choices, or trainable parameters) for which gradients are available is called the <strong>gradient source set</strong>. If the return value of the function is conditionally dependent on any element in the gradient source set given the arguments and values of all other random choices, for all possible traces of the function, then the generative function requires a <em>return value gradient</em> to compute gradients with respect to elements of the gradient source set. This static property of the generative function is reported by <a href="#Gen.accepts_output_grad"><code>accepts_output_grad</code></a>.</p><h2 id="Generative-function-interface"><a class="docs-heading-anchor" href="#Generative-function-interface">Generative function interface</a><a id="Generative-function-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Generative-function-interface" title="Permalink"></a></h2><p>The complete set of methods in the generative function interface (GFI) is:</p><article class="docstring"><header><a class="docstring-binding" id="Gen.simulate" href="#Gen.simulate"><code>Gen.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trace = simulate(gen_fn, args)</code></pre><p>Execute the generative function and return the trace.</p><p>Given arguments (<code>args</code>), sample <span>$(r, t) \sim p(\cdot; x)$</span> and return a trace with choice map <span>$t$</span>.</p><p>If <code>gen_fn</code> has optional trailing arguments (i.e., default values are provided), the optional arguments can be omitted from the <code>args</code> tuple. The generated trace  will have default values filled in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.generate" href="#Gen.generate"><code>Gen.generate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(trace::U, weight) = generate(gen_fn::GenerativeFunction{T,U}, args::Tuple)</code></pre><p>Return a trace of a generative function.</p><pre><code class="nohighlight hljs">(trace::U, weight) = generate(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                constraints::ChoiceMap)</code></pre><p>Return a trace of a generative function that is consistent with the given constraints on the random choices.</p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>constraints</code>) (which is empty for the first form), sample <span>$t \sim q(\cdot; u, x)$</span> and <span>$r \sim q(\cdot; x, t)$</span>, and return the trace <span>$(x, r, t)$</span> (<code>trace</code>). Also return the weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r, t; x)}{q(t; u, x) q(r; x, t)}\]</p><p>If <code>gen_fn</code> has optional trailing arguments (i.e., default values are provided), the optional arguments can be omitted from the <code>args</code> tuple. The generated trace  will have default values filled in.</p><p>Example without constraints:</p><pre><code class="language-julia hljs">(trace, weight) = generate(foo, (2, 4))</code></pre><p>Example with constraint that address <code>:z</code> takes value <code>true</code>.</p><pre><code class="language-julia hljs">(trace, weight) = generate(foo, (2, 4), choicemap((:z, true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L152-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.update" href="#Gen.update"><code>Gen.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, weight, retdiff, discard) = update(trace, args::Tuple, argdiffs::Tuple,
                                               constraints::ChoiceMap)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for some newly introduced random choice(s).</p><p>Given a previous trace <span>$(x, r, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a map <span>$u$</span> (<code>constraints</code>), return a new trace <span>$(x&#39;, r&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are either copied from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence) or are sampled from the internal proposal distribution.  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>. Sample <span>$t&#39; \sim q(\cdot; x&#39;, t + u)$</span>, and <span>$r&#39; \sim q(\cdot; x&#39;, t&#39;)$</span>, where <span>$t + u$</span> is the choice map obtained by merging <span>$t$</span> and <span>$u$</span> with <span>$u$</span> taking precedence for overlapping addresses.  Also return a weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r&#39;, t&#39;; x&#39;)}{q(r&#39;; x&#39;, t&#39;) q(t&#39;; x&#39;, t + u)}
- \log \frac{p(r, t; x)}{q(r; x, t)}\]</p><p>Note that <code>argdiffs</code> is expected to be the same length as <code>args</code>. If the function that generated <code>trace</code> supports default values for trailing arguments, then these arguments can be omitted from <code>args</code> and <code>argdiffs</code>. Note that if the original <code>trace</code> was generated using non-default argument values, then for each optional argument that is omitted, the old value will be over-written by the default argument value in the updated trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L245-L274">source</a></section><section><div><pre><code class="nohighlight hljs">(new_trace, weight, retdiff, discard) = update(trace, constraints::ChoiceMap)</code></pre><p>Shorthand variant of <a href="#Gen.update"><code>update</code></a> which assumes the arguments are unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L279-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.regenerate" href="#Gen.regenerate"><code>Gen.regenerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(new_trace, weight, retdiff) = regenerate(trace, args::Tuple, argdiffs::Tuple,
                                          selection::Selection)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices using the internal proposal distribution family.</p><p>Given a previous trace <span>$(x, r, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span> and sample <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>. Return the new trace <span>$(x&#39;, r&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r&#39;, t&#39;; x&#39;)}{q(t&#39;; u, x&#39;) q(r&#39;; x&#39;, t&#39;)}
- \log \frac{p(r, t; x)}{q(t; u&#39;, x) q(r; x, t)}\]</p><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p>Note that <code>argdiffs</code> is expected to be the same length as <code>args</code>. If the function that generated <code>trace</code> supports default values for trailing arguments, then these arguments can be omitted from <code>args</code> and <code>argdiffs</code>. Note that if the original <code>trace</code> was generated using non-default argument values, then for each optional argument that is omitted, the old value will be over-written by the default argument value in the regenerated trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L292-L319">source</a></section><section><div><pre><code class="nohighlight hljs">(new_trace, weight, retdiff) = regenerate(trace, selection::Selection)</code></pre><p>Shorthand variant of <a href="#Gen.regenerate"><code>regenerate</code></a> which assumes the arguments are unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L324-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p><p>Example:</p><pre><code class="language-julia hljs">args::Tuple = get_args(trace)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p><p>Example for generative function with return type <code>T</code>:</p><pre><code class="language-julia hljs">retval::T = get_retval(trace)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_choices" href="#Gen.get_choices"><code>Gen.get_choices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_choices(trace)</code></pre><p>Return a value implementing the assignment interface</p><p>Note that the value of any non-addressed randomness is not externally accessible.</p><p>Example:</p><pre><code class="language-julia hljs">choices::ChoiceMap = get_choices(trace)
z_val = choices[:z]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L36-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_score(trace)</code></pre><p>Return:</p><p class="math-container">\[\log \frac{p(r, t; x)}{q(r; x, t)}\]</p><p>When there is no non-addressed randomness, this simplifies to the log probability <span>$\log p(t; x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_gen_fn" href="#Gen.get_gen_fn"><code>Gen.get_gen_fn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_fn::GenerativeFunction = get_gen_fn(trace)</code></pre><p>Return the generative function that produced the given trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value = getindex(trace::Trace, addr)</code></pre><p>Get the value of the random choice, or auxiliary state (e.g. return value of inner function call), at address <code>addr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L71-L75">source</a></section><section><div><pre><code class="nohighlight hljs">retval = getindex(trace::Trace)
retval = trace[]</code></pre><p>Synonym for <a href="#Gen.get_retval"><code>get_retval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight = project(trace::U, selection::Selection)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace.</p><p>Given a trace <span>$(x, r, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r, t; x)}{q(t; u, x) q(r; x, t)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L192-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(choices, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p>Given arguments (<code>args</code>), sample <span>$t \sim p(\cdot; x)$</span> and <span>$r \sim p(\cdot; x, t)$</span>, and return <span>$t$</span> (<code>choices</code>) and the weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r, t; x)}{q(r; x, t)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L209-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, choices::ChoiceMap)</code></pre><p>Return the probability of proposing an assignment</p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>choices</code>) such that <span>$p(t; x) &gt; 0$</span>, sample <span>$r \sim q(\cdot; x, t)$</span> and return the weight (<code>weight</code>):</p><p class="math-container">\[\log \frac{p(r, t; x)}{q(r; x, t)}\]</p><p>It is an error if <span>$p(t; x) = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.has_argument_grads" href="#Gen.has_argument_grads"><code>Gen.has_argument_grads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bools::Tuple = has_argument_grads(gen_fn::Union{GenerativeFunction,Distribution})</code></pre><p>Return a tuple of booleans indicating whether a gradient is available for each of its arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.accepts_output_grad" href="#Gen.accepts_output_grad"><code>Gen.accepts_output_grad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">req::Bool = accepts_output_grad(gen_fn::GenerativeFunction)</code></pre><p>Return a boolean indicating whether the return value is dependent on any of the <em>gradient source elements</em> for any trace.</p><p>The gradient source elements are:</p><ul><li><p>Any argument whose position is true in <code>has_argument_grads</code></p></li><li><p>Any trainable parameter</p></li><li><p>Random choices made at a set of addresses that are selectable by <code>choice_gradients</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L115-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.accumulate_param_gradients!" href="#Gen.accumulate_param_gradients!"><code>Gen.accumulate_param_gradients!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arg_grads = accumulate_param_gradients!(trace, retgrad=nothing, scale_factor=1.)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace, optionally scaled, and return the gradient with respect to the arguments (not scaled).</p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><p class="math-container">\[∇_x \left( \log P(t; x) + J \right)\]</p><p>The length of <code>arg_grads</code> will be equal to the number of arguments to the function that generated <code>trace</code> (including any optional trailing arguments). If an argument is not annotated with <code>(grad)</code>, the corresponding value in <code>arg_grads</code> will be <code>nothing</code>.</p><p>Also increment the gradient accumulators for the trainable parameters <span>$Θ$</span> of the function by:</p><p class="math-container">\[∇_Θ \left( \log P(t; x) + J \right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L337-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.choice_gradients" href="#Gen.choice_gradients"><code>Gen.choice_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(arg_grads, choice_values, choice_grads) = choice_gradients(
    trace, selection=EmptySelection(), retgrad=nothing)</code></pre><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><p class="math-container">\[∇_x \left( \log P(t; x) + J \right)\]</p><p>The length of <code>arg_grads</code> will be equal to the number of arguments to the function that generated <code>trace</code> (including any optional trailing arguments). If an argument is not annotated with <code>(grad)</code>, the corresponding value in <code>arg_grads</code> will be <code>nothing</code>.</p><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><p class="math-container">\[∇_A \left( \log P(t; x) + J \right)\]</p><p>The gradient is represented as a choicemap whose value at (hierarchical) address <code>addr</code> is <span>$∂J/∂t[\texttt{addr}]$</span>.</p><p>Also return the choicemap (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L374-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gen.get_params" href="#Gen.get_params"><code>Gen.get_params</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_params(gen_fn::GenerativeFunction)</code></pre><p>Return an iterable over the trainable parameters of the generative function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/7955b07e6df273633da6e72d434884b73fbdffe6/src/gen_fn_interface.jl#L130-L134">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../distributions/">Probability Distributions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 September 2023 20:26">Wednesday 20 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
