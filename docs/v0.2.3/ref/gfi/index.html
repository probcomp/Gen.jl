<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Functions · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Language and API Reference</span><ul><li class="current"><a class="toctext" href>Generative Functions</a><ul class="internal"><li><a class="toctext" href="#Mathematical-definition-1">Mathematical definition</a></li><li><a class="toctext" href="#Traces-1">Traces</a></li><li><a class="toctext" href="#Trace-update-methods-1">Trace update methods</a></li><li><a class="toctext" href="#Differentiable-programming-1">Differentiable programming</a></li><li><a class="toctext" href="#Custom-generative-function-types-1">Custom generative function types</a></li></ul></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Generative Functions</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/gfi.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Functions-1" href="#Generative-Functions-1">Generative Functions</a></h1><p>One of the core abstractions in Gen is the <strong>generative function</strong>. Generative functions are used to represent a variety of different types of probabilistic computations including generative models, inference models, custom proposal distributions, and variational approximations.</p><p>Generative functions are represented by the following abstact type:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.GenerativeFunction" href="#Gen.GenerativeFunction"><code>Gen.GenerativeFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GenerativeFunction{T,U}</code></pre><p>Abstract type for a generative function with return value type T and trace type U.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L69-L73">source</a></section><p>There are various kinds of generative functions, which are represented by concrete subtypes of <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>. For example, the <a href="../modeling/#Built-in-Modeling-Language-1">Built-in Modeling Language</a> allows generative functions to be constructed using Julia function definition syntax:</p><pre><code class="language-julia">@gen function foo(a, b)
    if @trace(bernoulli(0.5), :z)
        return a + b + 1
    else
        return a + b
    end
end</code></pre><p>Generative functions behave like Julia functions in some respects. For example, we can call a generative function <code>foo</code> on arguments and get an output value using regular Julia call syntax:</p><pre><code class="language-julia-repl">&gt;julia foo(2, 4)
7</code></pre><p>However, generative functions are distinct from Julia functions because they support additional behaviors, described in the remainder of this section.</p><h2><a class="nav-anchor" id="Mathematical-definition-1" href="#Mathematical-definition-1">Mathematical definition</a></h2><p>Generative functions represent computations that accept some arguments, may use randomness internally, return an output, and cannot mutate externally observable state. We represent the randomness used during an execution of a generative function as a map from unique <strong>addresses</strong> to values, denoted <span>$t : A \to V$</span> where <span>$A$</span> is an address set and <span>$V$</span> is a set of possible values that random choices can take. In this section, we assume that random choices are discrete to simplify notation. We say that two random choice maps <span>$t$</span> and <span>$s$</span> <strong>agree</strong> if they assign the same value for any address that is in both of their domains.</p><p>Generative functions may also use <strong>untraced randomness</strong>, which is not included in the map <span>$t$</span>. However, the state of untraced random choices <em>is</em> maintained by the trace internally. We denote untraced randomness by <span>$r$</span>. Untraced randomness is useful for example, when calling black box Julia code that implements a randomized algorithm.</p><p>The observable behavior of every generative function is defined by the following mathematical objects:</p><h3><a class="nav-anchor" id=".-Input-type-1" href="#.-Input-type-1">1. Input type</a></h3><p>The set of valid argument tuples to the function, denoted <span>$X$</span>.</p><h3><a class="nav-anchor" id=".-Probability-distribution-family-1" href="#.-Probability-distribution-family-1">2. Probability distribution family</a></h3><p>A family of probability distributions <span>$p(t, r; x)$</span> on maps <span>$t$</span> from random choice addresses to their values, and untraced randomness <span>$r$</span>, indexed by arguments <span>$x$</span>, for all <span>$x \in X$</span>. Note that the distribution must be normalized:</p><div>\[\sum_{t, r} p(t, r; x) = 1 \;\; \mbox{for all} \;\; x \in X\]</div><p>This corresponds to a requirement that the function terminate with probabability 1 for all valid arguments. We use <span>$p(t; x)$</span> to denote the marginal distribution on the map <span>$t$</span>:</p><div>\[p(t; x) := \sum_{r} p(t, r; x)\]</div><p>And we denote the conditional distribution on untraced randomness <span>$r$</span>, given the map <span>$t$</span>, as:</p><div>\[p(r; x, t) := p(t, r; x) / p(t; x)\]</div><h3><a class="nav-anchor" id=".-Return-value-function-1" href="#.-Return-value-function-1">3. Return value function</a></h3><p>A (deterministic) function <span>$f$</span> that maps the tuple <span>$(x, t)$</span> of the arguments and the random choice map to the return value of the function (which we denote by <span>$y$</span>). Note that the return value cannot depend on the untraced randomness.</p><h3><a class="nav-anchor" id=".-Internal-proposal-distribution-family-1" href="#.-Internal-proposal-distribution-family-1">4. Internal proposal distribution family</a></h3><p>A family of probability distributions <span>$q(t; x, u)$</span> on maps <span>$t$</span> from random choice addresses to their values, indexed by tuples <span>$(x, u)$</span> where <span>$u$</span> is a map from random choice addresses to values, and where <span>$x$</span> are the arguments to the function. It must satisfy the following conditions:</p><div>\[\sum_{t} q(t; x, u) = 1 \;\; \mbox{for all} \;\; x \in X, u\]</div><div>\[p(t; x) &gt; 0 \mbox{ if and only if } q(t; x, u) &gt; 0 \mbox{ for all } u \mbox{ where } u \mbox{ and } t \mbox{ agree }\]</div><div>\[q(t; x, u) &gt; 0 \mbox{ implies that } u \mbox{ and } t \mbox{ agree }.\]</div><p>There is also a family of probability distributions <span>$q(r; x, t)$</span> on untraced randomness, that satisfies:</p><div>\[q(r; x, t) &gt; 0 \mbox{ if and only if } p(r; x, t) &gt; 0\]</div><h2><a class="nav-anchor" id="Traces-1" href="#Traces-1">Traces</a></h2><p>An <strong>execution trace</strong> (or just <em>trace</em>) is a record of an execution of a generative function. There is no abstract type representing all traces. Different concrete types of generative functions use different data structures and different Jula types for their traces. The trace type that a generative function uses is the second type parameter of the <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a> abstract type.</p><p>A trace of a generative function can be produced using:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.generate" href="#Gen.generate"><code>Gen.generate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = generate(gen_fn::GenerativeFunction{T,U}, args::Tuple)</code></pre><p>Return a trace of a generative function.</p><pre><code class="language-none">(trace::U, weight) = generate(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                constraints::ChoiceMap)</code></pre><p>Return a trace of a generative function that is consistent with the given constraints on the random choices.</p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>constraints</code>) (which is empty for the first form), sample <span>$t \sim q(\cdot; u, x)$</span> and <span>$r \sim q(\cdot; x, t)$</span>, and return the trace <span>$(x, t, r)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\log \frac{p(t, r; x)}{q(t; u, x) q(r; x, t)}\]</div><p>Example without constraints:</p><pre><code class="language-julia">(trace, weight) = generate(foo, (2, 4))</code></pre><p>Example with constraint that address <code>:z</code> takes value <code>true</code>.</p><pre><code class="language-julia">(trace, weight) = generate(foo, (2, 4), choicemap((:z, true))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L108-L135">source</a></section><p>The trace contains various information about the execution, including:</p><p>The arguments to the generative function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p><p>Example:</p><pre><code class="language-julia">args::Tuple = get_args(trace)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L5-L14">source</a></section><p>The return value of the generative function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p><p>Example for generative function with return type <code>T</code>:</p><pre><code class="language-julia">retval::T = get_retval(trace)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L17-L26">source</a></section><p>The map <span>$t$</span> from addresses of random choices to their values:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_choices" href="#Gen.get_choices"><code>Gen.get_choices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_choices(trace)</code></pre><p>Return a value implementing the assignment interface</p><p>Note that the value of any non-addressed randomness is not externally accessible.</p><p>Example:</p><pre><code class="language-julia">choices::ChoiceMap = get_choices(trace)
z_val = choices[:z]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L29-L42">source</a></section><p>The log probability that the random choices took the values they did:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span>. When there is no non-addressed randomness, this simplifies to the log probability `<span>$P(t; x)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L45-L49">source</a></section><p>A reference to the generative function that was executed:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_gen_fn" href="#Gen.get_gen_fn"><code>Gen.get_gen_fn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_fn::GenerativeFunction = get_gen_fn(trace)</code></pre><p>Return the generative function that produced the given trace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L52-L56">source</a></section><h2><a class="nav-anchor" id="Trace-update-methods-1" href="#Trace-update-methods-1">Trace update methods</a></h2><p>It is often important to update or adjust the trace of a generative function. In Gen, traces are <strong>persistent data structures</strong>, meaning they can be treated as immutable values. There are several methods that take a trace of a generative function as input and return a new trace of the generative function based on adjustments to the execution history of the function. We will illustrate these methods using the following generative function:</p><pre><code class="language-julia">@gen function foo()
    val = @trace(bernoulli(0.3), :a)
    if @trace(bernoulli(0.4), :b)
        val = @trace(bernoulli(0.6), :c) &amp;&amp; val
    else
        val = @trace(bernoulli(0.1), :d) &amp;&amp; val
    end
    val = @trace(bernoulli(0.7), :e) &amp;&amp; val
    return val
end</code></pre><p>Suppose we have a trace (<code>trace</code>) with initial choices:</p><pre><code class="language-none">│
├── :a : false
│
├── :b : true
│
├── :c : false
│
└── :e : true</code></pre><p>Note that address <code>:d</code> is not present because the branch in which <code>:d</code> is sampled was not taken because random choice <code>:b</code> had value <code>true</code>.</p><h3><a class="nav-anchor" id="Update-1" href="#Update-1">Update</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.update" href="#Gen.update"><code>Gen.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff, discard) = update(trace, args::Tuple, argdiff,
                                               constraints::ChoiceMap)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p>Given a previous trace <span>$(x, t, r)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a map <span>$u$</span> (<code>constraints</code>), return a new trace <span>$(x&#39;, t&#39;, r&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>. The new non-addressed randomness is sampled from <span>$r&#39; \sim q(\cdot; x&#39;, t&#39;)$</span>. Also return a weight (<code>weight</code>):</p><div>\[\log \frac{p(r&#39;, t&#39;; x&#39;) q(r; x, t)}{p(r, t; x) q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L195-L214">source</a></section><p>Suppose we run <a href="#Gen.update"><code>update</code></a> on the example <code>trace</code>, with the following constraints:</p><pre><code class="language-none">│
├── :b : false
│
└── :d : true</code></pre><pre><code class="language-julia">constraints = choicemap((:b, false), (:d, true))
(new_trace, w, _, discard) = update(trace, (), noargdiff, constraints)</code></pre><p>Then <code>get_choices(new_trace)</code> will be:</p><pre><code class="language-none">│
├── :a : false
│
├── :b : false
│
├── :d : true
│
└── :e : true</code></pre><p>and <code>discard</code> will be:</p><pre><code class="language-none">│
├── :b : true
│
└── :c : false</code></pre><p>Note that the discard contains both the previous values of addresses that were overwritten, and the values for addresses that were in the previous trace but are no longer in the new trace. The weight (<code>w</code>) is computed as:</p><div>\[p(t&#39;; x) = 0.7 × 0.4 × 0.4 × 0.7 = 0.0784\\
p(t; x&#39;) = 0.7 × 0.6 × 0.1 × 0.7 = 0.0294\\
w = \log p(t&#39;; x&#39;)/p(t; x) = \log 0.0294/0.0784 = \log 0.375\]</div><h3><a class="nav-anchor" id="Regenerate-1" href="#Regenerate-1">Regenerate</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.regenerate" href="#Gen.regenerate"><code>Gen.regenerate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = regenerate(trace, args::Tuple, argdiff,
                                          selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices using the internal proposal distribution family.</p><p>Given a previous trace <span>$(x, t, r)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span> and sample <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>. Return the new trace <span>$(x&#39;, t&#39;, r&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\log \frac{p(r&#39;, t&#39;; x&#39;) q(t; u&#39;, x) q(r; x, t)}{p(r, t; x) q(t&#39;; u, x&#39;) q(r&#39;; x&#39;, t&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L219-L238">source</a></section><p>Suppose we run <a href="#Gen.regenerate"><code>regenerate</code></a> on the example <code>trace</code>, with selection <code>:a</code> and <code>:b</code>:</p><pre><code class="language-julia">(new_trace, w, _) = regenerate(trace, (), noargdiff, select(:a, :b))</code></pre><p>Then, a new value for <code>:a</code> will be sampled from <code>bernoulli(0.3)</code>, and a new value for <code>:b</code> will be sampled from <code>bernoulli(0.4)</code>. If the new value for <code>:b</code> is <code>true</code>, then the previous value for <code>:c</code> (<code>false</code>) will be retained. If the new value for <code>:b</code> is <code>false</code>, then a new value for <code>:d</code> will be sampled from <code>bernoulli(0.7)</code>. The previous value for <code>:c</code> will always be retained. Suppose the new value for <code>:a</code> is <code>true</code>, and the new value for <code>:b</code> is <code>true</code>. Then <code>get_choices(new_trace)</code> will be:</p><pre><code class="language-none">│
├── :a : true
│
├── :b : true 
│
├── :c : false
│
└── :e : true</code></pre><p>The weight (<code>w</code>) is <span>$\log 1 = 0$</span>.</p><h3><a class="nav-anchor" id="Extend-1" href="#Extend-1">Extend</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(trace, args::Tuple, argdiff,
                                      constraints::ChoiceMap)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p>Given a previous trace <span>$(x, t, r)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>choices</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;, r&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span> and <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\log \frac{p(r&#39;, t&#39;; x&#39;) q(r; x, t)}{p(r, t; x) q(t&#39;; t + u, x&#39;) q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L243-L258">source</a></section><h3><a class="nav-anchor" id="Argdiffs-1" href="#Argdiffs-1">Argdiffs</a></h3><p>In addition to the input trace, and other arguments that indicate how to adjust the trace, each of these methods also accepts an <strong>args</strong> argument and an <strong>argdiff</strong> argument. The args argument contains the new arguments to the generative function, which may differ from the previous arguments to the generative function (which can be retrieved by applying <a href="#Gen.get_args"><code>get_args</code></a> to the previous trace). In many cases, the adjustment to the execution specified by the other arguments to these methods is &#39;small&#39; and only effects certain parts of the computation. Therefore, it is often possible to generate the new trace and the appropriate log probability ratios required for these methods without revisiting every state of the computation of the generative function. To enable this, the argdiff argument provides additional information about the <em>difference</em> between the previous arguments to the generative function, and the new arguments. This argdiff information permits the implementation of the update method to avoid inspecting the entire argument data structure to identify which parts were updated. Note that the correctness of the argdiff is in general not verified by Gen–-passing incorrect argdiff information may result in incorrect behavior.</p><p>The trace update methods for all generative functions above should accept at least the following types of argdiffs:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.NoArgDiff" href="#Gen.NoArgDiff"><code>Gen.NoArgDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const noargdiff = NoArgDiff()</code></pre><p>Indication that there was no change to the arguments of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/diff.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.UnknownArgDiff" href="#Gen.UnknownArgDiff"><code>Gen.UnknownArgDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const unknownargdiff = UnknownArgDiff()</code></pre><p>Indication that no information is provided about the change to the arguments of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/diff.jl#L18-L22">source</a></section><p>Generative functions may also accept custom types for their argdiffs that allow more precise information about the different to be supplied. It is the responsibility of the author of a generative function to specify the valid argdiff types in the documentation of their function, and it is the responsibility of the user of a generative function to construct and pass in the appropriate argdiff value.</p><h3><a class="nav-anchor" id="Retdiffs-1" href="#Retdiffs-1">Retdiffs</a></h3><p>To enable generative functions that invoke other functions to efficiently make use of incremental computation, the trace update methods of generative functions also return a <strong>retdiff</strong> value, which provides information about the difference in the return value of the previous trace an the return value of the new trace.</p><p>Generative functions may return arbitrary retdiff values, provided that the type has the following method:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.isnodiff" href="#Gen.isnodiff"><code>Gen.isnodiff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnodiff(retdiff)::Bool</code></pre><p>Return true if the given retdiff value indicates no change to the return value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/diff.jl#L52-L56">source</a></section><p>It is the responsibility of the author of the generative function to document the possible retdiff values that may be returned, and how the should be interpreted. There are two generic constant retdiff provided for authors of generative functions to use in simple cases:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.DefaultRetDiff" href="#Gen.DefaultRetDiff"><code>Gen.DefaultRetDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const defaultretdiff = DefaultRetDiff()</code></pre><p>A default retdiff value that provides no information about the return value difference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/diff.jl#L32-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.NoRetDiff" href="#Gen.NoRetDiff"><code>Gen.NoRetDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const noretdiff = NoRetDiff()</code></pre><p>A retdiff value that indicates that there was no difference to the return value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/diff.jl#L42-L46">source</a></section><h2><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h2><p>Generative functions may support computation of gradients with respect to (i) all or a subset of its arguments, (ii) its <strong>trainable parameters</strong>, and (iii) the value of certain random choices. The set of elements (either arguments, trainable parameters, or random choices) for which gradients are available is called the <em>gradient source set</em>. A generative function statically reports whether or not it is able to compute gradients with respect to each of its arguments, through the function <code>has_argument_grads</code>. Let <span>$x_G$</span> denote the set of arguments for which the generative function does support gradient computation. Similarly, a generative function supports gradients with respect the value of random choices made at all or a subset of addresses. If the return value of the function is conditionally independent of each element in the gradient source set given the other elements in the gradient source set and values of all other random choices, for all possible traces of the function, then the generative function requires a <em>return value gradient</em> to compute gradients with respect to elements of the gradient source set. This static property of the generative function is reported by <code>accepts_output_grad</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_argument_grads" href="#Gen.has_argument_grads"><code>Gen.has_argument_grads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bools::Tuple = has_argument_grads(gen_fn::Union{GenerativeFunction,Distribution})</code></pre><p>Return a tuple of booleans indicating whether a gradient is available for each of its arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L79-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.accepts_output_grad" href="#Gen.accepts_output_grad"><code>Gen.accepts_output_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">req::Bool = accepts_output_grad(gen_fn::GenerativeFunction)</code></pre><p>Return a boolean indicating whether the return value is dependent on any of the <em>gradient source elements</em> for any trace.</p><p>The gradient source elements are:</p><ul><li><p>Any argument whose position is true in <code>has_argument_grads</code></p></li><li><p>Any static parameter</p></li><li><p>Random choices made at a set of addresses that are selectable by <code>choice_gradients</code>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L86-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.accumulate_param_gradients!" href="#Gen.accumulate_param_gradients!"><code>Gen.accumulate_param_gradients!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = accumulate_param_gradients!(trace, retgrad, scaler=1.)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace, optionally scaled, and return the gradient with respect to the arguments (not scaled).</p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L263-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.choice_gradients" href="#Gen.choice_gradients"><code>Gen.choice_gradients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = choice_gradients(trace, selection::AddressSet,
                                                            retgrad)</code></pre><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L288-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_params" href="#Gen.get_params"><code>Gen.get_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_params(gen_fn::GenerativeFunction)</code></pre><p>Return an iterable over the trainable parameters of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L101-L105">source</a></section><h3><a class="nav-anchor" id="Additional-methods-1" href="#Additional-methods-1">Additional methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p>Given a trace <span>$(x, t, r)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\log \frac{p(r, t; x)}{q(t; u, x) q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L144-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(choices, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p>Given arguments (<code>args</code>), sample <span>$t \sim p(\cdot; x)$</span> and <span>$r \sim p(\cdot; x, t)$</span>, and return <span>$t$</span> (<code>choices</code>) and the weight (<code>weight</code>):</p><div>\[\log \frac{p(r, t; x)}{q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L161-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, choices::ChoiceMap)</code></pre><p>Return the probability of proposing an assignment</p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>choices</code>) such that <span>$p(t; x) &gt; 0$</span>, sample <span>$r \sim q(\cdot; x, t)$</span> and  return the weight (<code>weight</code>):</p><div>\[\log \frac{p(r, t; x)}{q(r; x, t)}\]</div><p>It is an error if <span>$p(t; x) = 0$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/71214671c175071adbc2b08108230186baa09844/src/gen_fn_interface.jl#L177-L189">source</a></section><h2><a class="nav-anchor" id="Custom-generative-function-types-1" href="#Custom-generative-function-types-1">Custom generative function types</a></h2><p>Most users can just use generative functions written in the <a href="../modeling/#Built-in-Modeling-Language-1">Built-in Modeling Language</a>, and can skip this section. However, to develop new modeling DSLs, or optimized implementations of certain probabilistic modeling components, users can also implement custom types of generative functions. We recommend the following steps for implementing a new type of generative function, and also looking at the implementation for the <a href="../modeling/#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a> type as an example.</p><h3><a class="nav-anchor" id="Define-a-trace-data-type-1" href="#Define-a-trace-data-type-1">Define a trace data type</a></h3><pre><code class="language-julia">struct MyTraceType
    ..
end</code></pre><h3><a class="nav-anchor" id="Decide-the-return-type-for-the-generative-function-1" href="#Decide-the-return-type-for-the-generative-function-1">Decide the return type for the generative function</a></h3><p>Suppose our return type is <code>Vector{Float64}</code>.</p><h3><a class="nav-anchor" id="Define-a-data-type-for-your-generative-function-1" href="#Define-a-data-type-for-your-generative-function-1">Define a data type for your generative function</a></h3><p>This should be a subtype of <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>, with the appropriate type parameters.</p><pre><code class="language-julia">struct MyGenerativeFunction &lt;: GenerativeFunction{Vector{Float64},MyTraceType}
..
end</code></pre><p>Note that your generative function may not need to have any fields. You can create a constructor for it, e.g.:</p><pre><code class="language-none">function MyGenerativeFunction(...)
..
end</code></pre><h3><a class="nav-anchor" id="Decide-what-the-arguments-to-a-generative-function-should-be-1" href="#Decide-what-the-arguments-to-a-generative-function-should-be-1">Decide what the arguments to a generative function should be</a></h3><p>For example, our generative functions might take two arguments, <code>a</code> (of type <code>Int</code>) and <code>b</code> (of type <code>Float64</code>). Then, the argument tuple passed to e.g. <a href="#Gen.generate"><code>generate</code></a> will have two elements.</p><p>NOTE: Be careful to distinguish between arguments to the generative function itself, and arguments to the constructor of the generative function. For example, if you have a generative function type that is parametrized by, for example, modeling DSL code, this DSL code would be a parameter of the generative function constructor.</p><h3><a class="nav-anchor" id="Decide-what-the-traced-random-choices-(if-any)-will-be-1" href="#Decide-what-the-traced-random-choices-(if-any)-will-be-1">Decide what the traced random choices (if any) will be</a></h3><p>Remember that each random choice is assigned a unique address in (possibly) hierarchical address space. You are free to design this address space as you wish, although you should document it for users of your generative function type.</p><h3><a class="nav-anchor" id="Implement-the-methods-of-the-interface-1" href="#Implement-the-methods-of-the-interface-1">Implement the methods of the interface</a></h3><ul><li><p>At minimum, you need to implement all methods under the <a href="ref/@ref"><code>Traces</code></a> heading (e.g. <a href="#Gen.generate"><code>generate</code></a>, ..)</p></li><li><p>To support <a href="../inference/#Gen.metropolis_hastings"><code>metropolis_hastings</code></a> or local optimization, or local iterative adjustments to traces, be sure to implement the <a href="#Gen.update"><code>update</code></a> and <a href="#Gen.regenerate"><code>regenerate</code></a> methods.</p></li><li><p>To support gradients of the log probability density with respect to the arguments and/or random choices made by the function, implement the <a href="#Gen.choice_gradients"><code>choice_gradients</code></a> method.</p></li><li><p>Generative functions can also have trainable parameters (e.g. neural network weights). To support these, implement the <a href="#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a> method.</p></li><li><p>To support use of your generative function in custom proposals (instead of just generative models), implement <a href="#Gen.assess"><code>assess</code></a> and <a href="#Gen.propose"><code>propose</code></a> methods.</p></li></ul><footer><hr/><a class="previous" href="../../tutorials/"><span class="direction">Previous</span><span class="title">Tutorials</span></a><a class="next" href="../distributions/"><span class="direction">Next</span><span class="title">Probability Distributions</span></a></footer></article></body></html>
