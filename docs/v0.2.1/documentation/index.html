<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gen Documentation · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Gen Introduction</a></li><li class="current"><a class="toctext" href>Gen Documentation</a><ul class="internal"><li><a class="toctext" href="#Assignments-1">Assignments</a></li><li><a class="toctext" href="#Address-Selections-1">Address Selections</a></li><li><a class="toctext" href="#Traces-and-Generative-Functions-1">Traces and Generative Functions</a></li><li><a class="toctext" href="#Distributions-1">Distributions</a></li><li><a class="toctext" href="#Trie-1">Trie</a></li><li class="toplevel"><a class="toctext" href="#Modeling-DSLs-1">Modeling DSLs</a></li><li><a class="toctext" href="#Dynamic-DSL-1">Dynamic DSL</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gen Documentation</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/documentation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gen Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gen-Documentation-1" href="#Gen-Documentation-1">Gen Documentation</a></h1><h2><a class="nav-anchor" id="Assignments-1" href="#Assignments-1">Assignments</a></h2><p>An <em>assignment</em> is a map from addresses of random choices to their values. Assignments are represented using the abstract type <code>Assignment</code>. Assignments have the following methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_value" href="#Gen.has_value"><code>Gen.has_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_value(assmt::Assignment, addr)</code></pre><p>Return true if there is a value at the given address.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_value" href="#Gen.get_value"><code>Gen.get_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_value(assmt::Assignment, addr)</code></pre><p>Return the value at the given address in the assignment, or throw a KeyError if no value exists. A syntactic sugar is <code>Base.getindex</code>:</p><pre><code class="language-none">value = assmt[addr]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L23-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_subassmt" href="#Gen.get_subassmt"><code>Gen.get_subassmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subassmt = get_subassmt(assmt::Assignment, addr)</code></pre><p>Return the sub-assignment containing all choices whose address is prefixed by addr.</p><p>It is an error if the assignment contains a value at the given address. If there are no choices whose address is prefixed by addr then return an <code>EmptyAssignment</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L12-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_values_shallow" href="#Gen.get_values_shallow"><code>Gen.get_values_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_subassmt_iterable = get_values_shallow(assmt::Assignment)</code></pre><p>Return an iterable collection of tuples <code>(key, subassmt::Assignment)</code> for each top-level key associated with a value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_subassmts_shallow" href="#Gen.get_subassmts_shallow"><code>Gen.get_subassmts_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_subassmt_iterable = get_subassmts_shallow(assmt::Assignment)</code></pre><p>Return an iterable collection of tuples <code>(key, subassmt::Assignment)</code> for each top-level key that has a non-empty sub-assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L33-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.to_array" href="#Gen.to_array"><code>Gen.to_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arr::Vector{T} = to_array(assmt::Assignment, ::Type{T}) where {T}</code></pre><p>Populate an array with values of choices in the given assignment.</p><p>It is an error if each of the values cannot be coerced into a value of the given type.</p><p><strong>Implementation</strong></p><p>To support <code>to_array</code>, a concrete subtype <code>T &lt;: Assignment</code> should implement the following method:</p><pre><code class="language-none">n::Int = _fill_array!(assmt::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Populate <code>arr</code> with values from the given assignment, starting at <code>start_idx</code>, and return the number of elements in <code>arr</code> that were populated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L138-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.from_array" href="#Gen.from_array"><code>Gen.from_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assmt::Assignment = from_array(proto_assmt::Assignment, arr::Vector)</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from the given array.</p><p>The order in which addresses are populated is determined by the prototype assignment. It is an error if the number of choices in the prototype assignment is not equal to the length the array.</p><p><strong>Implementation</strong></p><p>To support <code>from_array</code>, a concrete subtype <code>T &lt;: Assignment</code> should implement the following method:</p><pre><code class="language-none">(n::Int, assmt::T) = _from_array(proto_assmt::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from <code>arr</code>, starting at position <code>start_idx</code>, and the number of elements read from <code>arr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L164-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.pair" href="#Gen.pair"><code>Gen.pair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assmt = pair(assmt1::Assignment, assmt2::Assignment, key1::Symbol, key2::Symbol)</code></pre><p>Return an assignment that contains <code>assmt1</code> as a sub-assignment under <code>key1</code> and <code>assmt2</code> as a sub-assignment under <code>key2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L347-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.unpair" href="#Gen.unpair"><code>Gen.unpair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt1, assmt2) = unpair(assmt::Assignment, key1::Symbol, key2::Symbol)</code></pre><p>Return the two sub-assignments at <code>key1</code> and <code>key2</code>, one or both of which may be empty.</p><p>It is an error if there are any top-level values, or any non-empty top-level sub-assignments at keys other than <code>key1</code> and <code>key2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L357-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assmt = Base.merge(assmt1::Assignment, assmt2::Assignment)</code></pre><p>Merge two assignments.</p><p>It is an error if the assignments both have values at the same address, or if one assignment has a value at an address that is the prefix of the address of a value in the other assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L195-L203">source</a></section><p>TODO: change <code>get_assmt</code> to <code>assmt</code> TODO: simplify other method names</p><h3><a class="nav-anchor" id="Address-Schemata-1" href="#Address-Schemata-1">Address Schemata</a></h3><p>An <em>address schema</em> provides information about the set of addresses of random choices in an assignment.</p><p>Address schemata are associated with the <em>type</em> of an assignment:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_address_schema" href="#Gen.get_address_schema"><code>Gen.get_address_schema</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">schema = get_address_schema(::Type{T}) where {T &lt;: Assignment}</code></pre><p>Return the (top-level) address schema for the given assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/assignment.jl#L5-L9">source</a></section><p>The remainder if this section describes some concrete types that subtype <code>Assignment</code>.</p><h3><a class="nav-anchor" id="Dynamic-Assignment-1" href="#Dynamic-Assignment-1">Dynamic Assignment</a></h3><p>A <code>DynamicAssignment</code> is mutable, and can contain arbitrary values for its keys.</p><ul><li><p>DynamicAssignment()</p></li><li><p>set_value! (with syntactic sugar Base.setindex!), will cause any previous value or sub-assignment at this addr to be deleted. it is an error if there is already a value present at some prefix of addr.</p></li><li><p>set_subassmt!, will cause any previous value or sub-assignment at this addr to be deleted. it is an error if there is already a value present at some prefix of addr.</p></li></ul><h3><a class="nav-anchor" id="Static-Assignment-1" href="#Static-Assignment-1">Static Assignment</a></h3><p>A <code>StaticAssignment</code> is a immutable and contains only symbols as its keys for leaf nodes and for internal nodes. A <code>StaticAssignment</code> has type parameters<code>R</code> and <code>T</code> that are tuples of <code>Symbol</code>s that are the keys of the leaf nodes and internal nodes respectively, so that code can be generated that is specialized to the particular set of keys in the trie:</p><pre><code class="language-julia">struct StaticAssignment{R,S,T,U} &lt;: Assignment
    leaf_nodes::NamedTuple{R,S}
    internal_nodes::NamedTuple{T,U}
end </code></pre><p>A <code>StaticAssignment</code> with leaf symbols <code>:a</code> and <code>:b</code> and internal key <code>:c</code> can be constructed using syntax like:</p><pre><code class="language-julia">trie = StaticAssignment((a=1, b=2), (c=inner_trie,))</code></pre><p>TODO: use generated functions in a lot more places, e.g. <code>get_subassmt</code></p><p>TODO: document static variants of getters:</p><ul><li><p><code>static_get_subassmt(assmt, ::Val{key})</code>: throws a key error if the key isn&#39;t in the static address schema (get_subassmt would return an EmptyAssignment)</p></li><li><p>NOTE: <code>static_has_value(assmt, ::Val{key})</code> appears in the Static IR, but this an internal implementation detail, and not part of the &#39;static assignment interface&#39;.</p></li></ul><h3><a class="nav-anchor" id="Other-Concrete-Assignment-Types-1" href="#Other-Concrete-Assignment-Types-1">Other Concrete Assignment Types</a></h3><ul><li><p>EmptyAssignment</p></li><li><p>InternalVectorAssignment (TODO rename to DeepVectorAssignment)</p></li><li><p>ShallowVectorAssignment (TODO not yet implemented)</p></li><li><p>Assignments produced from <code>GFTrace</code>s</p></li><li><p>Assignments produced </p></li></ul><h2><a class="nav-anchor" id="Address-Selections-1" href="#Address-Selections-1">Address Selections</a></h2><ul><li>AddressSet</li></ul><p>TODO: document AddressSet API TODO: consider changing names of method in AddressSet API</p><ul><li><p>AddressSchema</p></li><li><p>DynamicAddressSet</p></li><li><p>StaticAddressSet</p></li></ul><h2><a class="nav-anchor" id="Traces-and-Generative-Functions-1" href="#Traces-and-Generative-Functions-1">Traces and Generative Functions</a></h2><p>A <em>trace</em> is a record of an execution of a generative function. There is no abstract type representing all traces. Generative functions implement the <em>generative function interface</em>, which is a set of methods that involve the execution traces and probabilistic behavior of generative functions. In the mathematical description of the interface methods, we denote arguments to a function by <span>$x$</span>, complete assignments of values to addresses of random choices (containing all the random choices made during some execution) by <span>$t$</span> and partial assignments by either <span>$u$</span> or <span>$v$</span>. We denote a trace of a generative function by the tuple <span>$(x, t)$</span>. We say that two assignments <span>$u$</span> and <span>$t$</span> <em>agree</em> when they assign addresses that appear in both assignments to the same values (they can different or even disjoint sets of addresses and still agree). A generative function is associated with a family of probability distributions <span>$P(t; x)$</span> on assignments <span>$t$</span>, parameterized by arguments <span>$x$</span>, and a second family of distributions <span>$Q(t; u, x)$</span> on assignments <span>$t$</span> parameterized by partial assignment <span>$u$</span> and arguments <span>$x$</span>. <span>$Q$</span> is called the <em>internal proposal family</em> of the generative function, and satisfies that if <span>$u$</span> and <span>$t$</span> agree then <span>$P(t; x) &gt; 0$</span> if and only if <span>$Q(t; x, u) &gt; 0$</span>, and that <span>$Q(t; x, u) &gt; 0$</span> implies that <span>$u$</span> and <span>$t$</span> agree. See the <a href="http://hdl.handle.net/1721.1/119255">Gen technical report</a> for additional details.</p><p>Generative functions may also use <em>non-addressable random choices</em>, denoted <span>$r$</span>. Unlike regular (addressable) random choices, non-addressable random choices do not have addresses, and the value of non-addressable random choices is not exposed through the generative function interface. However, the state of non-addressable random choices is maintained in the trace. A trace that contains non-addressable random choices is denoted <span>$(x, t, r)$</span>. Non-addressable random choices manifest to the user of the interface as stochasticity in weights returned by generative function interface methods. The behavior of non-addressable random choices is defined by an additional pair of families of distributions associated with the generative function, denoted <span>$Q(r; x, t)$</span> and <span>$P(r; x, t)$</span>, which are defined for <span>$P(t; x) &gt; 0$</span>, and which satisfy <span>$Q(r; x, t) &gt; 0$</span> if and only if <span>$P(r; x, t) &gt; 0$</span>. For each generative function below, we describe its semantics first in the basic setting where there is no non-addressable random choices, and then in the more general setting that may include non-addressable random choices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize" href="#Gen.initialize"><code>Gen.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = initialize(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                assmt::Assignment)</code></pre><p>Return a trace of a generative function that is consistent with the given assignment.</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>assmt</code>), sample <span>$t \sim Q(\cdot; u, x)$</span> and return the trace <span>$(x, t)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, the trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L70-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p><strong>Basic case</strong></p><p>Given a trace <span>$(x, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L100-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p><strong>Basic case</strong></p><p>Given arguments (<code>args</code>), sample <span>$t&#39; \sim P(\cdot; x)$</span>, and return <span>$t$</span> (<code>assmt</code>) and the weight (<code>weight</code>) <span>$P(t; x)$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim P(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L128-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, assmt::Assignment)</code></pre><p>Return the probability of proposing an assignment</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>assmt</code>) such that <span>$P(t; x) &gt; 0$</span>, return the weight (<code>weight</code>) <span>$P(t; x)$</span>.  It is an error if <span>$P(t; x) = 0$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L151-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.force_update" href="#Gen.force_update"><code>Gen.force_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = force_update(args::Tuple, argdiff, trace,
                                                     assmt::Assignment)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L176-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.fix_update" href="#Gen.fix_update"><code>Gen.fix_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = fix_update(args::Tuple, argdiff, trace,
                                                   assmt::Assignment)</code></pre><p>Update a trace, by changing the arguments and/or providing new values for some existing random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  Let <span>$u + t$</span> denote the merge of <span>$u$</span> and <span>$t$</span> (with <span>$u$</span> taking precedence).  Sample <span>$t&#39; \sim Q(\cdot; u + t, x)$</span>. All addresses in <span>$u$</span> must appear in <span>$t$</span> and in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the values from <span>$t$</span> for addresses in <span>$u$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)} \cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L211-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.free_update" href="#Gen.free_update"><code>Gen.free_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = free_update(args::Tuple, argdiff, trace,
                                           selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span>.  Return the new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L246-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(args::Tuple, argdiff, trace, assmt::Assignment)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, and we also sample <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L283-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_params" href="#Gen.backprop_params"><code>Gen.backprop_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = backprop_params(trace, retgrad)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L313-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_trace" href="#Gen.backprop_trace"><code>Gen.backprop_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = backprop_trace(trace, selection::AddressSet,
                                                          retgrad)</code></pre><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L341-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_assmt" href="#Gen.get_assmt"><code>Gen.get_assmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_assmt(trace)</code></pre><p>Return a value implementing the assignment interface</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p><strong>Basic case</strong></p><p>Return <span>$P(t; x)$</span></p><p><strong>General case</strong></p><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/gen_fn_interface.jl#L26-L36">source</a></section><p>TODO: document <code>has_argument_grads</code></p><h2><a class="nav-anchor" id="Distributions-1" href="#Distributions-1">Distributions</a></h2><p>Probability distributions are singleton types whose supertype is <code>Distribution{T}</code>, where <code>T</code> indicates the data type of the random sample.</p><pre><code class="language-julia">abstract type Distribution{T} end</code></pre><p>By convention, distributions have a global constant lower-case name for the singleton value. For example:</p><pre><code class="language-julia">struct Bernoulli &lt;: Distribution{Bool} end
const bernoulli = Bernoulli()</code></pre><p>Distributions must implement two methods, <code>random</code> and <code>logpdf</code>.</p><p><code>random</code> returns a random sample from the distribution:</p><pre><code class="language-julia">x::Bool = random(bernoulli, 0.5)
x::Bool = random(Bernoulli(), 0.5)</code></pre><p><code>logpdf</code> returns the log probability (density) of the distribution at a given value:</p><pre><code class="language-julia">logpdf(bernoulli, false, 0.5)
logpdf(Bernoulli(), false, 0.5)</code></pre><p>Distribution values are also callable, which is a syntactic sugar with the same behavior of calling <code>random</code>:</p><pre><code class="language-julia">bernoulli(0.5) # identical to random(bernoulli, 0.5) and random(Bernoulli(), 0.5)</code></pre><h3><a class="nav-anchor" id="Gradients-of-Distributions-1" href="#Gradients-of-Distributions-1">Gradients of Distributions</a></h3><p>Distributions may also implement <code>logpdf_grad</code>, which returns the gradient of the log probability (density) with respect to the random sample and the parameters, as a tuple:</p><pre><code class="language-julia">(grad_sample, grad_mu, grad_std) = logpdf_grad(normal, 1.324, 0.0, 1.0)</code></pre><p>The partial derivative of the log probability (density) with respect to the random sample, or one of the parameters, might not always exist. Distributions indicate which partial derivatives exist using the methods <code>has_output_grad</code> and <code>has_argument_grads</code>:</p><pre><code class="language-julia">has_output_grad(::Normal) = true
has_argument_grads(::Normal) = (true, true)</code></pre><p>If a particular partial derivative does not exist, that field of the tuple returned by <code>logpdf_grad</code> should be <code>nothing</code>.</p><h3><a class="nav-anchor" id="Built-In-Distributions-1" href="#Built-In-Distributions-1">Built-In Distributions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.bernoulli" href="#Gen.bernoulli"><code>Gen.bernoulli</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">bernoulli(prob_true::Real)</code></pre><p>Samples a <code>Bool</code> value which is true with given probability</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.normal" href="#Gen.normal"><code>Gen.normal</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">normal(mu::Real, std::Real)</code></pre><p>Samples a <code>Float64</code> value from a normal distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.mvnormal" href="#Gen.mvnormal"><code>Gen.mvnormal</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">mvnormal(mu::AbstractVector{T}, cov::AbstractMatrix{U}} where {T&lt;:Real,U&lt;:Real}</code></pre><p>Samples a <code>Vector{Float64}</code> value from a multivariate normal distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L95-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.gamma" href="#Gen.gamma"><code>Gen.gamma</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">gamma(shape::Real, scale::Real)</code></pre><p>Sample a <code>Float64</code> from a gamma distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L133-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.inv_gamma" href="#Gen.inv_gamma"><code>Gen.inv_gamma</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">inv_gamma(shape::Real, scale::Real)</code></pre><p>Sample a <code>Float64</code> from a inverse gamma distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L171-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.beta" href="#Gen.beta"><code>Gen.beta</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">beta(alpha::Real, beta::Real)</code></pre><p>Sample a <code>Float64</code> from a beta distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.categorical" href="#Gen.categorical"><code>Gen.categorical</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">categorical(probs::AbstractArray{U, 1}) where {U &lt;: Real}</code></pre><p>Given a vector of probabilities <code>probs</code> where <code>sum(probs) = 1</code>, sample an <code>Int</code> <code>i</code> from the set {1, 2, .., <code>length(probs)</code>} with probability <code>probs[i]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L250-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.uniform" href="#Gen.uniform"><code>Gen.uniform</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">uniform(low::Real, high::Real)</code></pre><p>Sample a <code>Float64</code> from the uniform distribution on the interval [low, high].</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L321-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.uniform_discrete" href="#Gen.uniform_discrete"><code>Gen.uniform_discrete</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">uniform_discrete(low::Integer, high::Integer)</code></pre><p>Sample an <code>Int</code> from the uniform distribution on the set {low, low + 1, ..., high-1, high}.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L285-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.poisson" href="#Gen.poisson"><code>Gen.poisson</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">poisson(lambda::Real)</code></pre><p>Sample an <code>Int</code> from the Poisson distribution with rate <code>lambda</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/393b109dcb27a29e0c739f21356dd0b39db55265/src/distribution.jl#L355-L359">source</a></section><h2><a class="nav-anchor" id="Trie-1" href="#Trie-1">Trie</a></h2><h1><a class="nav-anchor" id="Modeling-DSLs-1" href="#Modeling-DSLs-1">Modeling DSLs</a></h1><h2><a class="nav-anchor" id="Dynamic-DSL-1" href="#Dynamic-DSL-1">Dynamic DSL</a></h2><p>TODO: remove the <code>@ad</code> return value differentiation flag</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Gen Introduction</span></a></footer></article></body></html>
