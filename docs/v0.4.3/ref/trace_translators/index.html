<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trace Translators · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Modeling Languages and APIs</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li class="current"><a class="toctext" href>Trace Translators</a><ul class="internal"><li><a class="toctext" href="#Deterministic-Trace-Translators-1">Deterministic Trace Translators</a></li><li><a class="toctext" href="#General-Trace-Translators-1">General Trace Translators</a></li><li><a class="toctext" href="#Symmetric-Trace-Translators-1">Symmetric Trace Translators</a></li><li><a class="toctext" href="#Simple-Extending-Trace-Translators-1">Simple Extending Trace Translators</a></li><li><a class="toctext" href="#Trace-Transform-DSL-1">Trace Transform DSL</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li><li><a class="toctext" href="../extending/">Extending Gen</a></li></ul></li><li><span class="toctext">Standard Inference Library</span><ul><li><a class="toctext" href="../importance/">Importance Sampling</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../pf/">Particle Filtering</a></li><li><a class="toctext" href="../vi/">Variational Inference</a></li><li><a class="toctext" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modeling Languages and APIs</li><li><a href>Trace Translators</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/trace_translators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Trace Translators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Trace-Translators-1" href="#Trace-Translators-1">Trace Translators</a></h1><p>While <a href="../gfi/#Generative-Functions-1">Generative Functions</a> define probability distributions on traces, <strong>Trace Translators</strong> convert from one space of traces to another space of traces. Trace translators are building blocks of inference programs that utilize multiple model representations, like <a href="../mcmc/#Involutive-MCMC-1">Involutive MCMC</a>.</p><p>Trace translators are significantly more general than <a href="https://www.tensorflow.org/probability/api_docs/python/tfp/bijectors/Bijector">Bijectors</a>. Trace translators can (i) convert between spaces of traces that include mixed numeric discrete random choices, as well as stochastic control flow, and (ii) convert between spaces for which there is no one-to-one correspondence (e.g. between models of different dimensionality, or between discrete and continuous models). Bijectors are limited to deterministic transformations between real-valued vectors of constant dimension.</p><h2><a class="nav-anchor" id="Deterministic-Trace-Translators-1" href="#Deterministic-Trace-Translators-1">Deterministic Trace Translators</a></h2><p>Inference programs manipulate traces, but they also keep track of probabilities and probability densities associated with these traces. Suppose we have two generative functions <code>p1</code> and <code>p2</code>. Given a trace <code>t2</code> of <code>p2</code> we can easily compute the probability (or probability density) that the trace would have been generated by <code>p2</code> using <code>get_score(t2)</code>. But suppose we want to construct the trace of <code>p2</code> first sampling a trace <code>t1</code> of <code>p1</code> and then applying a deterministic transformation to that trace to obtain <code>t2</code>. How can we compute the probability that a trace <code>t2</code> would have been produced by this process? This probability is needed if, for example, <code>p2</code> defines a probabilistic model and want to use <code>p1</code> as a proposal distribution within importance sampling. If we produce <code>t2</code> via an arbitrary deterministic transformation of the random choices in <code>t1</code>, then computing the necessary probability is difficult.</p><p>If we restrict ourselves to deterministic transformations that are <em>bijections</em> (one-to-one correspondences) from the set of traces of <code>p1</code> to the set of traces of <code>p2</code>, then the problem is much simplified. If the transformation is a bijection this means that (i) each trace of <code>p1</code> gets mapped to a different trace of <code>p2</code>, and (ii) for every trace of <code>p2</code> there is some trace of <code>p1</code> that maps to it. Bijective transformations between traces are useful components of inference programs because the probability that a given trace <code>t2</code> of <code>p2</code> would have been produced by first sampling from <code>p1</code> and then applying the transform can be computed simply as the probability that <code>p1</code> would produce  the (unique) trace <code>t1</code> that gets mapped to the given trace by the transform. Conceptually, bijective trace transforms <em>preserve probability</em>. When trace transforms operate on traces with continuous random choices, computing probability densities of the transformed traces requires computing a Jacobian associated with the continuous part of the transformation.</p><p>Gen provides a DSL for expressing bijections between spaces of traces, called the <strong>Trace Transform DSL</strong>. We introduce this DSL via an example. Below are two generative functions. The first samples polar coordinates and the second uses cartesian coordinates.</p><pre><code class="language-julia">@gen function p1()
    r ~ inv_gamma(1, 1)
    theta ~ uniform(-pi/2, pi/2)
end</code></pre><pre><code class="language-julia">@gen function p2()
    x ~ normal(0, 1)
    y ~ normal(0, 1)
end</code></pre><h3><a class="nav-anchor" id="Defining-a-trace-transform-with-the-Trace-Transform-DSL-1" href="#Defining-a-trace-transform-with-the-Trace-Transform-DSL-1">Defining a trace transform with the Trace Transform DSL</a></h3><p>The following trace transform DSL program defines a transformation (called <code>f</code>) that transforms traces of <code>p1</code> into traces of <code>p2</code>:</p><pre><code class="language-julia">@transform f (t1) to (t2) begin
    r = @read(t1[:r], :continuous)
    theta = @read(t1[:theta], :continuous)
    @write(t2[:x], r * cos(theta), :continuous)
    @write(t2[:y], r * sin(theta), :continuous)
end</code></pre><p>This transform reads values of random choices in the input trace (<code>t1</code>) at specific addresses (indicated by the syntax <code>t1[addr]</code>) using <code>@read</code> and writes values to the output trace (<code>t2</code>) using <code>@write</code>. Each read and write operation is labeled with whether the random choice is discrete or continuous. The section <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a> defines the DSL in more detail.</p><p>It is usually a good idea to write the inverse of the bijection. The inverse can provide a dynamic check that the transform truly is a bijection. The inverse of the above transformation is:</p><pre><code class="language-julia">@transform finv (t2) to (t1) begin
    x = @read(t2[:x], :continuous)
    y = @read(t2[:y], :continuous)
    r = sqrt(x^2 + y^2)
    @write(t1[:r], sqrt(x^2 + y^2), :continuous)
    @write(t1[:theta], atan(y, x), :continuous)
end</code></pre><p>We can inform Gen that two transforms are inverses of one another using <a href="#Gen.pair_bijections!"><code>pair_bijections!</code></a>:</p><pre><code class="language-julia">pair_bijections!(f, finv)</code></pre><h3><a class="nav-anchor" id="Wrapping-a-trace-transform-in-a-trace-translator-1" href="#Wrapping-a-trace-transform-in-a-trace-translator-1">Wrapping a trace transform in a trace translator</a></h3><p>Note that the transform DSL code does not specify what the two generative functions are, or what the arguments to these generative functions are. This information will be required for computing probabilities and probability densities of traces. We provide this information by constructing a <strong>Trace Translator</strong> that wraps the transform along with this transformation:</p><pre><code class="language-julia">translator = DeterministicTraceTranslator(p2, (), choicemap(), f)</code></pre><p>We then can then apply the translator to a trace of <code>p1</code> using function call syntax. The translator returns a trace of <code>p2</code> and a log-weight that we can use to compute the probability (density) of the resulting trace:</p><pre><code class="language-julia">t2, log_weight = translator(t1)</code></pre><p>Specifically, the log probability (density) that the trace <code>t2</code> was produced by first sampling <code>t1 = simulate(p1, ())</code> and then applying the trace translator, is:</p><pre><code class="language-julia">get_score(t1) + log_weight</code></pre><p>Let&#39;s unpack the previous few code blocks in more detail. First, note that we did not pass in the source generative function (<code>p1</code>) or its arguments (<code>()</code>) when we constructed the trace translator. This is because this information will be attached to the input trace <code>t1</code> itself. We <em>did</em> need to pass in the target generative function (<code>p2</code>) and its arguments (<code>()</code>) however, because this information is not included in <code>t1</code>.</p><p>In this case, because continuous random choices are involved, the probabilities are probability densities, and the trace translator used automatic differentiation of the code in the transform <code>f</code> to compute a change-of-variables Jacobian that is necessary to compute the correct probability density of the new trace <code>t2</code>.</p><h3><a class="nav-anchor" id="Observations-1" href="#Observations-1">Observations</a></h3><p>Typically, there are observations associated with one or both of the generative functions involved, and we have values for these in a choice map, so we do not want the trace translator to be responsible for populating the values of these observed random choices. For example, suppose we want to condition <code>p2</code> on an observed random choice <code>z</code>:</p><pre><code class="language-julia">@gen function p2()
    x ~ normal(0, 1)
    y ~ normal(0, 1)
    z ~ normal(x + y, 0.1)
end
observations = choicemap()
observations[:z] = 2.3</code></pre><p>When <code>p2</code> has observations, these can be passed in as an additional argument to the trace translator constructor:</p><pre><code class="language-julia">translator = DeterministicTraceTranslator(p2, (), observations, f)</code></pre><h3><a class="nav-anchor" id="Discrete-random-choices-and-stochastic-control-flow-1" href="#Discrete-random-choices-and-stochastic-control-flow-1">Discrete random choices and stochastic control flow</a></h3><p>Trace transforms and trace translators interoperate seamlessly with discrete random choices and stochastic control flow. Both the input and the output traces can contain a mix of discrete and continuous choices, and arbitrary stochastic control flow. Consider the following simple example, where we use two different discrete representations to represent probability distributions the integers 0-7:</p><pre><code class="language-julia">@gen function p1()
    bit1 ~ bernoulli(0.5)
    bit2 ~ bernoulli(0.5)
    bit3 ~ bernoulli(0.5)
end</code></pre><pre><code class="language-julia">@gen function p2()
    n ~ categorical([0.1, 0.1, 0.1, 0.2, 0.2, 0.15, 0.15])
end</code></pre><p>We define the forward and inverse transforms:</p><pre><code class="language-julia">@transform f (t1) to (t2) begin
    n = (
        @read(t1[:bit1], :discrete) * 1 +
        @read(t1[:bit2], :discrete) * 2 +
        @read(t1[:bit3], :discrete) * 4)
    @write(t2[:n], n, :discrete)
end</code></pre><pre><code class="language-julia">@transform finv (t2) to (t1) begin
    bits = digits(@read(t2[:n], :discrete), base=2)
    @write(t1[:bit1], bits[1], :discrete)
    @write(t1[:bit2], bits[2], :discrete)
    @write(t1[:bit3], bits[3], :discrete)
end</code></pre><p>Here is an example that includes discrete random choices, stochastic control flow, and continuous random choices.</p><pre><code class="language-julia">@gen function p1()
    if ({:branch} ~ bernoulli(0.5))
        x ~ normal(0, 1)
    else
        other ~ categorical([0.3, 0.7])
    end
end</code></pre><pre><code class="language-julia">@gen function p2()
    k ~ uniform_discrete(1, 4)
    if k &lt;= 2
        y ~ gamma(1, 1)
    end
end</code></pre><p>Note that transformations between spaces of traces need not be intuitive (although they probably should)! Try to convince yourself that the functions below are indeed a pair of bijections between the traces of these two generative functions.</p><pre><code class="language-julia">@transform f (t1) to (t2) begin
    if @read(t1[:branch], :discrete)
        x = @read(t1[:x], :continuous)
        if x &gt; 0
            @write(t2[:k], 2, :discrete)
        else
            @write(t2[:k], 1, :discrete)
        end
        @write(t2[:y], abs(x), :continuous)
    else
        other = @read(t1[:other], :discrete)
        @write(t2[:k], (other == 1) ? 3 : 4, :discrete)
    end
end</code></pre><pre><code class="language-julia">@transform finv (t2) to (t1) begin
    k = @read(t2[:k], :discrete)
    if k &lt;= 2
        y = @read(t2[:y], :continuous)
        @write(t2[:x], (k == 1) ? -y : y, :continuous)
    else
        @write(t1[:other], (k == 3) ? 1 : 2, :discrete)
    end
end</code></pre><h2><a class="nav-anchor" id="General-Trace-Translators-1" href="#General-Trace-Translators-1">General Trace Translators</a></h2><p>Note that for two arbitrary generative functions <code>p1</code> and <code>p2</code> there may not exist any one-to-one correspondence between their spaces of traces. For example, consider a generative function <code>p1</code> that samples points within the unit square <span>$[0, 1]^2$</span></p><pre><code class="language-julia">@gen function p1()
    x ~ uniform(0, 1)
    y ~ uniform(0, 1)
end</code></pre><p>and another generative function <code>p2</code> that samples one of 100 possible discrete values, each value representing one cell of the unit square:</p><pre><code class="language-julia">@gen function p2()
    i ~ uniform_discrete(1, 10) # interval [(i-1)/10, i/10]
    j ~ uniform_discrete(1, 10) # interval [(j-1)/10, j/10]
end</code></pre><p>There is no one-to-one correspondence between the spaces of traces of these two generative functions: The first is an uncountably infinite set, and the other is a finite set with 100 elements in it.</p><p>However, there is an intuitive notion of correspondence that we would like to be able to encode. Each discrete cell <span>$(i, j)$</span> corresponds to a subset of the unit square <span>$[(i - 1)/10, i/10] \times [(j-1)/10, j/10]$</span>.</p><p>We can express this correspondence (and any correspondence between two arbitrary generative functions) by introducing two auxiliary generative functions <code>q1</code> and <code>q2</code>. The first function <code>q1</code> will take a trace of <code>p1</code> as input, and the second function <code>q2</code> will take a trace of <code>p2</code> as input. Then, instead of a transfomation between traces of <code>p1</code> and traces of <code>p2</code> our trace transform will transform between (i) the space of pairs of traces of <code>p1</code> and <code>q1</code> and (ii) the space of pairs of traces of <code>p2</code> and <code>q2</code>. We construct <code>q1</code> and <code>q2</code> so that the two spaces have the same size, and a one-to-one correspondence is possible.</p><p>For our example above, we construct <code>q2</code> to sample the coordinate (<span>$[0, 0.1]^2$</span>) relative to the cell. We construct <code>q1</code> to be empty–there is already a mapping from each trace of <code>p1</code> to each trace of <code>p2</code> that simply identifies what cell <span>$(i, j)$</span> a given point in <span>$[0, 1]^2$</span> is in, so no extra random choices are needed.</p><pre><code class="language-julia">@gen function q1(p1_trace)
end

@gen function q2(p2_trace)
    dx ~ uniform(0.0, 0.1)
    dy ~ uniform(0.0, 0.1)
end</code></pre><h3><a class="nav-anchor" id="Trace-transforms-between-pairs-of-traces-1" href="#Trace-transforms-between-pairs-of-traces-1">Trace transforms between pairs of traces</a></h3><p>To handle general trace translators that require auxiliary probability distributions, the trace trace DSL supports defining transformations between <em>pairs</em> of traces. For example, the following defines a trace transform that maps from pairs of traces of <code>p1</code> and <code>q1</code> to pairs of traces of <code>p2</code> and <code>q2</code>:</p><pre><code class="language-julia">@transform f (p1_trace, q1_trace) to (p2_trace, q2_trace) begin
    x = @read(p1_trace[:x], :continuous)
    y = @read(p1_trace[:y], :continuous)
    i = ceil(x * 10)
    j = ceil(y * 10)
    @write(p2_trace[:i], i, :discrete)
    @write(p2_trace[:j], j, :discrete)
    @write(q2_trace[:dx], x - (i-1)/10, :continuous)
    @write(q2_trace[:dy], y - (j-1)/10, :continuous)
end</code></pre><p>and the inverse transform:</p><pre><code class="language-julia">@transform f_inv (p2_trace, q2_trace) to (p1_trace, q1_trace) begin
    i = @read(p2_trace[:i], :discrete)
    j = @read(p2_trace[:j], :discrete)
    dx = @read(q2_trace[:dx], :continuous)
    dy = @read(q2_trace[:dy], :continuous)
    x = (i-1)/10 + dx
    y = (j-1)/10 + dy
    @write(p1_trace[:x], x, :continuous)
    @write(p1_trace[:y], y, :continuous)
end</code></pre><p>which we associate as inverses:</p><pre><code class="language-julia">pair_bijections!(f, f_inv)</code></pre><h3><a class="nav-anchor" id="Constructing-a-general-trace-translator-1" href="#Constructing-a-general-trace-translator-1">Constructing a general trace translator</a></h3><p>We now wrap the transform above into a general trace translator, by providing the three probabilistic programs <code>p2</code>, <code>q1</code>, <code>q2</code> that it uses (a reference to <code>p1</code> will included in the input trace), and the arguments to these functions.</p><pre><code class="language-julia">translator = GeneralTraceTranslator(
    p_new=p2,
    p_new_args=(),
    new_observations=choicemap(),
    q_forward=q1,
    q_forward_args=(),
    q_backward=q2,
    q_backward_args=(),
    f=f)</code></pre><p>Then, we can apply the trace translator to a trace (<code>t1</code>) of <code>p1</code> and get a trace (<code>t2</code>) of <code>p2</code> and a log-weight:</p><pre><code class="language-julia">t2, log_weight = translator(t1)</code></pre><h2><a class="nav-anchor" id="Symmetric-Trace-Translators-1" href="#Symmetric-Trace-Translators-1">Symmetric Trace Translators</a></h2><p>When the previous and new generative functions (e.g. <code>p1</code> and <code>p2</code> in the previous example) are the same, and their arguments are the same, and <code>q_forward</code> and <code>q_backward</code> (and their arguments) are also identical, we call this the trace translator a <strong>Symmetric Trace Translator</strong>. Symmetric trace translators are important because they form the basis of <a href="../mcmc/#Involutive-MCMC-1">Involutive MCMC</a>. Instead of translating a trace of one generative function to the trace of another generative function, they translate a trace of a generative function to another trace of the <em>same</em> generative function.</p><p>Symmetric trace translators have the interesting property that the function <code>f</code> is an <strong>involution</strong>, or a function that is its own inverse. To indicate that a trace transform is an involution, use <a href="#Gen.is_involution!"><code>is_involution!</code></a>.</p><p>Because symmetric trace translators translate within the same generative function, their implementation uses <a href="../gfi/#Gen.update"><code>update</code></a> to incrementally modify the trace from the previous to the new trace. This has two benefits when the previous and new traces have random choices that aren&#39;t modified between them: (i) the incremental modification may be more efficient than writing the new trace entirely from scratch, and (ii) the transform DSL program does not need to specify a value for addresses whose value is not changed from the previous trace.</p><h2><a class="nav-anchor" id="Simple-Extending-Trace-Translators-1" href="#Simple-Extending-Trace-Translators-1">Simple Extending Trace Translators</a></h2><p>Simple extending trace translators extend an existing trace with new random choices sampled from a proposal distribution, as well as any new observations. The arguments of the trace may also be updated. This type of trace translation is the basic operation used in <a href="../pf/#Particle-Filtering-1">Particle Filtering</a>. For example, we might have a model that sequentially samples new latent variables <code>(:z, t)</code> and observations <code>(:x, t)</code> for each timestep <code>t</code>:</p><pre><code class="language-julia">@gen function model(T::Int)
    for t in 1:T
        z = {(:z, t)} ~ normal(0, 1)
        x = {(:x, t)} ~ normal(z, 1)
    end
end</code></pre><p>Each time we observe a new <code>(:x ,t)</code>, we might want to propose <code>(:z, t)</code> so that it is close in value:</p><pre><code class="language-julia">@gen function proposal(trace::Trace, x::Real)
    t = get_args(trace)[1] + 1
    {(:z, t)} ~ normal(x, 1)
end</code></pre><p>Suppose we initially generated a trace up to timestep <code>t=1</code>, e.g. by calling <code>t1 = simulate(model, (1,))</code>. Now we observe <code>(:x, 2)</code> to be <code>5.0</code>. By constructing a simple extending trace translator, we can simultaneously update the trace <code>t1</code> with new arguments, introduce the new observation at <code>(:x, 2)</code>, and propose a likely value for <code>(:z, 2)</code>:</p><pre><code class="language-julia">translator = SimpleExtendingTraceTranslator(
    p_new_args=(2,), p_argdiffs=(UnknownChange(),),
    new_observations=choicemap((:x, 2) =&gt; 5.0),
    q_forward=proposal, q_forward_args=(5.0,))
t2, log_weight = translator(t1)</code></pre><p>Similar functionality can be achieved through a combination of <a href="../gfi/#Gen.propose"><code>propose</code></a> on the proposal and <a href="../gfi/#Gen.update"><code>update</code></a> on the original trace, but using a trace translator provides a nice layer of abstraction.</p><h2><a class="nav-anchor" id="Trace-Transform-DSL-1" href="#Trace-Transform-DSL-1">Trace Transform DSL</a></h2><p>The <strong>Trace Transform DSL</strong> is a differentiable programming language for writing deterministic transformations of traces. Programs written in this DSL are called <em>transforms</em>. Transforms read the value of random choices from input trace(s) and write values of random choices to output trace(s). These programs are not typically executed directly by users, but are instead wrapped into one of the several forms of trace translators listed above (<a href="#Gen.GeneralTraceTranslator"><code>GeneralTraceTranslator</code></a>, and <a href="#Gen.SymmetricTraceTranslator"><code>SymmetricTraceTranslator</code></a>).</p><p>A transform is identified with the <a href="#Gen.@transform"><code>@transform</code></a> macro, and uses one of the following four syntactic forms for the signature (the name of the transform, and the names of the input and output traces are all user-defined varibles; the only keywords are <code>@transform</code>, <code>to</code>, <code>begin</code>, and <code>end</code>):</p><p><em>A transform from one trace to another, without extra parameters</em></p><pre><code class="language-julia">@transform f t1 to t2 begin
    ...
end</code></pre><p><em>A transform from one trace to another, with extra parameters</em></p><pre><code class="language-julia">@transform f(x, y, ..) t1 to t2 begin
    ...
end</code></pre><p><em>A transform from pairs of traces to pairs of traces, without extra parameters</em></p><pre><code class="language-julia">@transform f (t1, t2) to (t3, t4) begin
    ...
end</code></pre><p><em>A transform from one trace to another, with extra parameters</em></p><pre><code class="language-julia">@transform f(x, y, ..) (t1, t2) to (t3, t4) begin
    ...
end</code></pre><p>The extra parameters are optional, and can be used to pass arguments to a transform function that is invoked, from another transform function, using the <a href="ref/@ref"><code>@tcall</code></a> macro. For example:</p><pre><code class="language-julia">@transform g(x) t1 to t2 begin
    ...
end
@transform f t1 to t2 begin
    x = ..
    @tcall(g(x))
end</code></pre><p>The callee transform function (<code>g</code> above) reads and writes to the same input and output traces as the caller transform function (<code>f</code> above). Note that the input and output traces can be assigned different names in the caller and the callee.</p><p>The body of a transform reads the values of random choices at addresses in the input trace(s), performs computation using regular Julia code (provided this code can be differentiated with <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>) and writes valeus of random choices at addresses in the output trace(s). In the body <a href="#Gen.@read"><code>@read</code></a> expressions read a value from a particular address of an input trace:</p><pre><code class="language-none">val = @read(&lt;source&gt;, &lt;type-label&gt;)</code></pre><p>where <code>&lt;source&gt;</code> is an expression of the form <code>&lt;trace&gt;[&lt;addr&gt;]</code> where <code>&lt;trace&gt;</code> must be the name of an input trace in the transform&#39;s signature. The <code>&lt;type-label&gt;</code> is either <code>:continuous</code> or <code>:discrete</code>, and indicates whether the random choice is discrete or continuous (in measure-theoretic terms, whether it uses the counting measure, or a Lebesgue-measure a Euclidean space of some dimension). Similarly, <a href="#Gen.@write"><code>@write</code></a> expressions write a value to a particular address in an output trace:</p><pre><code class="language-none">@write(&lt;destination&gt;, &lt;value&gt;, &lt;type-label&gt;)</code></pre><p>Sometimes trace transforms need to directly copy the value from one address in an input trace to one address in an output trace. In these cases, it is recommended to use the explicit <a href="#Gen.@copy"><code>@copy</code></a> expression:</p><pre><code class="language-none">@copy(&lt;source&gt;, &lt;destination&gt;)</code></pre><p>where <code>&lt;source&gt;</code> and <code>&lt;destination&gt;</code> are of the form <code>&lt;trace&gt;[&lt;addr&gt;]</code> as above. Note you can also copy collections of multiple random choices under an address namespace in an input trace to an address namespace in an output trace. For example,</p><pre><code class="language-none">@copy(trace1[:foo], trace2[:bar])</code></pre><p>will copy every random choice in <code>trace1</code> with an address of the form <code>:foo =&gt; &lt;rest&gt;</code> to <code>trace2</code> at address <code>:bar =&gt; &lt;rest&gt;</code>.</p><p>It is also possible to read the <em>return value</em> from an input trace using the following syntax, but this value must be discrete (in the local neighborhood of traces, the return value must be constant as a function of all continuous random choices in input traces):</p><pre><code class="language-none">val = @read(&lt;trace&gt;[], :discrete)</code></pre><p>This feature is useful when the generative function precomputes a quantity as part of its return value, and we would like to reuse this value, instead of having to recompute it as part of the transform. The `discrete&#39; requirement is needed because the transform DSL does not currently backpropagate through the return value (this feature could be added in the future).</p><p>Tips for defining valid transforms:</p><ul><li><p>If you find yourself copying the same continuous source address to multiple locations, it probably means your transform is not valid (the Jacobian matrix will have rows that are identical, and so the Jacobian determinant will be zero).</p></li><li><p>You can gain some confidence that your transform is valid by enabling dynamic checks (<code>check=true</code>) in the trace translator that uses it.</p></li></ul><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.@transform" href="#Gen.@transform"><code>Gen.@transform</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@transform f[(params...)] (in1 [,in2]) to (out1 [,out2])
    ..
end</code></pre><p>Write a program in the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L107-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.@read" href="#Gen.@read"><code>Gen.@read</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@read(&lt;source&gt;, &lt;annotation&gt;)</code></pre><p>Macro for reading the value of a random choice from an input trace in the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a>.</p><p>&lt;source&gt; is of the form &lt;trace&gt;[&lt;addr&gt;] where &lt;trace&gt; is an input trace, and &lt;annotation&gt; is either :discrete or :continuous.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L182-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.@write" href="#Gen.@write"><code>Gen.@write</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@write(&lt;destination&gt;, &lt;value&gt;, &lt;annotation&gt;)</code></pre><p>Macro for writing the value of a random choice to an output trace in the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a>.</p><p>&lt;destination&gt; is of the form &lt;trace&gt;[&lt;addr&gt;] where &lt;trace&gt; is an input trace, and &lt;annotation&gt; is either :discrete or :continuous.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L194-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.@copy" href="#Gen.@copy"><code>Gen.@copy</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@copy(&lt;source&gt;, &lt;destination&gt;)</code></pre><p>Macro for copying the value of a random choice (or a whole namespace of random choices) from an input trace to an output trace in the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a>.</p><p>&lt;destination&gt; is of the form &lt;trace&gt;[&lt;addr&gt;] where &lt;trace&gt; is an input trace, and &lt;annotation&gt; is either :discrete or :continuous.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L206-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.pair_bijections!" href="#Gen.pair_bijections!"><code>Gen.pair_bijections!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pair_bijections!(f1::TraceTransformDSLProgram, f2::TraceTransformDSLProgram)</code></pre><p>Assert that a pair of bijections contsructed using the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a> are inverses of one another.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L23-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.is_involution!" href="#Gen.is_involution!"><code>Gen.is_involution!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_involution!(f::TraceTransformDSLProgram)</code></pre><p>Assert that a bijection constructed with the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a> is its own inverse.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.inverse" href="#Gen.inverse"><code>Gen.inverse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">b::TraceTransformDSLProgram = inverse(a::TraceTransformDSLProgram)</code></pre><p>Obtain the inverse of a bijection that was constructed with the <a href="#Trace-Transform-DSL-1">Trace Transform DSL</a>.</p><p>The inverse must have been associated with the bijection either via <a href="#Gen.pair_bijections!"><code>pair_bijections!</code></a> or [<code>is_involution!</code>])(@ref).</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/b3387c04c5f2c8ad598175dfb421a6cacf50cfe1/src/inference/trace_translators.jl#L45-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.DeterministicTraceTranslator" href="#Gen.DeterministicTraceTranslator"><code>Gen.DeterministicTraceTranslator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">translator = DeterministicTraceTranslator(;
    p_new::GenerativeFunction, p_args::Tuple=();
    new_observations::ChoiceMap=EmptyChoiceMap()
    f::TraceTransformDSLProgram)</code></pre><p>Constructor for a deterministic trace translator.</p><p>Run the translator with:</p><pre><code class="language-none">(output_trace, log_weight) = translator(input_trace)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.GeneralTraceTranslator" href="#Gen.GeneralTraceTranslator"><code>Gen.GeneralTraceTranslator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">translator = GeneralTraceTranslator(;
    p_new::GenerativeFunction,
    p_new_args::Tuple = (),
    new_observations::ChoiceMap = EmptyChoiceMap(),
    q_forward::GenerativeFunction,
    q_forward_args::Tuple  = (),
    q_backward::GenerativeFunction,
    q_backward_args::Tuple  = (),
    f::TraceTransformDSLProgram)</code></pre><p>Constructor for a general trace translator.</p><p>Run the translator with:</p><pre><code class="language-none">(output_trace, log_weight) = translator(input_trace; check=false, prev_observations=EmptyChoiceMap())</code></pre><p>Use <code>check</code> to enable a bijection check (this requires that the transform <code>f</code> has been paired with its inverse using <a href="ref/@ref">`pair_bijections!</a> or <a href="ref/@ref"><code>is_involution</code></a>).</p><p>If <code>check</code> is enabled, then <code>prev_observations</code> is a choice map containing the observed random choices in the previous trace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.SimpleExtendingTraceTranslator" href="#Gen.SimpleExtendingTraceTranslator"><code>Gen.SimpleExtendingTraceTranslator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">translator = SimpleExtendingTraceTranslator(;
    p_new_args::Tuple = (),
    p_argdiffs::Tuple = (),
    new_observations::ChoiceMap = EmptyChoiceMap(),
    q_forward::GenerativeFunction,
    q_forward_args::Tuple  = ())</code></pre><p>Constructor for a simple extending trace translator.</p><p>Run the translator with:</p><pre><code class="language-none">(output_trace, log_weight) = translator(input_trace)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.SymmetricTraceTranslator" href="#Gen.SymmetricTraceTranslator"><code>Gen.SymmetricTraceTranslator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">translator = SymmetricTraceTranslator(;
    q::GenerativeFunction,
    q_args::Tuple = (),
    involution::Union{TraceTransformDSLProgram,Function})</code></pre><p>Constructor for a symmetric trace translator.</p><p>The involution is either constructed via the <a href="#Gen.@transform"><code>@transform</code></a> macro (recommended), or can be provided as a Julia function.</p><p>Run the translator with:</p><pre><code class="language-none">(output_trace, log_weight) = translator(input_trace; check=false, observations=EmptyChoiceMap())</code></pre><p>Use <code>check</code> to enable the involution check (this requires that the transform <code>f</code> has been marked with <a href="ref/@ref"><code>is_involution</code></a>).</p><p>If <code>check</code> is enabled, then <code>observations</code> is a choice map containing the observed random choices, and the check will additionally ensure they are not mutated by the involution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L20">source</a></section><footer><hr/><a class="previous" href="../parameter_optimization/"><span class="direction">Previous</span><span class="title">Optimizing Trainable Parameters</span></a><a class="next" href="../extending/"><span class="direction">Next</span><span class="title">Extending Gen</span></a></footer></article></body></html>
