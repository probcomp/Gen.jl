<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in Modeling Language · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Language and API Reference</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li class="current"><a class="toctext" href>Built-in Modeling Language</a><ul class="internal"><li><a class="toctext" href="#Annotations-1">Annotations</a></li><li><a class="toctext" href="#Making-random-choices-1">Making random choices</a></li><li><a class="toctext" href="#Calling-generative-functions-1">Calling generative functions</a></li><li><a class="toctext" href="#Composite-addresses-1">Composite addresses</a></li><li><a class="toctext" href="#Return-value-1">Return value</a></li><li><a class="toctext" href="#Trainable-parameters-1">Trainable parameters</a></li><li><a class="toctext" href="#Differentiable-programming-1">Differentiable programming</a></li><li><a class="toctext" href="#Static-Modeling-Language-1">Static Modeling Language</a></li></ul></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Built-in Modeling Language</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/modeling.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Built-in Modeling Language</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Built-in-Modeling-Language-1" href="#Built-in-Modeling-Language-1">Built-in Modeling Language</a></h1><p>Gen provides a built-in embedded modeling language for defining generative functions. The language uses a syntax that extends Julia&#39;s syntax for defining regular Julia functions.</p><p>Generative functions in the modeling language are identified using the <code>@gen</code> keyword in front of a Julia function definition. Here is an example <code>@gen</code> function that samples two random choices:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(prob), :b)
    return z1 || z2
end</code></pre><p>After running this code, <code>foo</code> is a Julia value of type <a href="#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.DynamicDSLFunction" href="#Gen.DynamicDSLFunction"><code>Gen.DynamicDSLFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicDSLFunction{T} &lt;: GenerativeFunction{T,DynamicDSLTrace}</code></pre><p>A generative function based on a shallowly embedding modeling language based on Julia functions.</p><p>Constructed using the <code>@gen</code> keyword. Most methods in the generative function interface involve a end-to-end execution of the function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/dynamic/dynamic.jl#L3-L10">source</a></section><p>We can call the resulting generative function like we would a regular Julia function:</p><pre><code class="language-julia">retval::Bool = foo(0.5)</code></pre><p>We can also trace its execution:</p><pre><code class="language-julia">(trace, _) = generate(foo, (0.5,))</code></pre><p>See <a href="../gfi/#Generative-Functions-1">Generative Functions</a> for the full set of operations supported by a generative function. Note that the built-in modeling language described in this section is only one of many ways of defining a generative function – generative functions can also be constructed using other embedded languages, or by directly implementing the methods of the generative function interface. However, the built-in modeling language is intended to being flexible enough cover a wide range of use cases. In the remainder of this section, we refer to generative functions defined using the built-in modeling language as <code>@gen</code> functions.</p><h2><a class="nav-anchor" id="Annotations-1" href="#Annotations-1">Annotations</a></h2><p>Annotations are a syntactic construct in the built-in modeling language that allows users to provide additional information about how <code>@gen</code> functions should be interpreted. Annotations are optional, and not necessary to understand the basics of Gen. There are two types of annotations – <em>argument annotations</em> and <em>function annotations</em>.</p><p><strong>Argument annotations.</strong> In addition to type declarations on arguments like regular Julia functions, <code>@gen</code> functions also support additional annotations on arguments. Each argument can have the following different syntactic forms:</p><ul><li><p><code>y</code>: No type declaration; no annotations.</p></li><li><p><code>y::Float64</code>: Type declaration; but no annotations.</p></li><li><p><code>(grad)(y)</code>: No type declaration provided;, annotated with <code>grad</code>.</p></li><li><p><code>(grad)(y::Float64)</code>: Type declaration provided; and annotated with <code>grad</code>.</p></li></ul><p>Currently, the possible argument annotations are:</p><ul><li><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</li></ul><p><strong>Function annotations.</strong> The <code>@gen</code> function itself can also be optionally associated with zero or more annotations, which are separate from the per-argument annotations. Function-level annotations use the following different syntactic forms:</p><ul><li><p><code>@gen function foo(&lt;args&gt;) &lt;body&gt; end</code>: No function annotations.</p></li><li><p><code>@gen (grad) function foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has the <code>grad</code> annotation.</p></li><li><p><code>@gen (grad,static) function foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has both the <code>grad</code> and <code>static</code> annotations.</p></li></ul><p>Currently the possible function annotations are:</p><ul><li><p><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</p></li><li><p><code>static</code> (see <a href="ref/@ref">Static DSL</a>).</p></li></ul><h2><a class="nav-anchor" id="Making-random-choices-1" href="#Making-random-choices-1">Making random choices</a></h2><p>Random choices are made by calling a probability distribution on some arguments:</p><pre><code class="language-julia">val::Bool = bernoulli(0.5)</code></pre><p>See <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a> for the set of built-in probability distributions, and for information on implementing new probability distributions.</p><p>In the body of a <code>@gen</code> function, wrapping a call to a random choice with an <code>@trace</code> expression associates the random choice with an <em>address</em>, and evaluates to the value of the random choice. The syntax is:</p><pre><code class="language-julia">@trace(&lt;distribution&gt;(&lt;args&gt;), &lt;addr&gt;)</code></pre><p>Addresses can be any Julia value. Here, we give the Julia symbol address <code>:z</code> to a Bernoulli random choice.</p><pre><code class="language-julia">val::Bool = @trace(bernoulli(0.5), :z)</code></pre><p>Not all random choices need to be given addresses. An address is required if the random choice will be observed, or will be referenced by a custom inference algorithm (e.g. if it will be proposed to by a custom proposal distribution).</p><h3><a class="nav-anchor" id="Choices-should-have-constant-support-1" href="#Choices-should-have-constant-support-1">Choices should have constant support</a></h3><p>The support of a random choice at a given address (the set of values with nonzero probability or probability density) must be constant across all possible executions of the <code>@gen</code> function. Violating this discipline will cause errors in certain cases. If the support of a random choice needs to change, use a different address for each distinct value of the support. For example, consider the following generative function:</p><pre><code class="language-julia">@gen function foo()
    n = @trace(categorical([0.5, 0.5]), :n) + 1
    @trace(categorical(ones(n) / n), :x)
end</code></pre><p>The support of the random choice with address <code>:x</code> is either the set <span>$\{1, 2\}$</span> or <span>$\{1, 2, 3\}$</span>. Therefore, this random choice does satisfy our condition above. This would cause an error with the following, in which the <code>:n</code> address is modified, which could result in a change to the domain of the <code>:x</code> variable:</p><pre><code class="language-julia">tr, _ = generate(foo, (), choicemap((:n, 2), (:x, 3)))
tr, _ = mh(tr, select(:n))</code></pre><p>We can modify the address to satisfy the condition by including the domain in the address:</p><pre><code class="language-julia">@gen function foo()
    n = @trace(categorical([0.5, 0.5]), :n) + 1
    @trace(categorical(ones(n) / n), (:x, n))
end</code></pre><h2><a class="nav-anchor" id="Calling-generative-functions-1" href="#Calling-generative-functions-1">Calling generative functions</a></h2><p><code>@gen</code> functions can invoke other generative functions in three ways:</p><p><strong>Untraced call</strong>: If <code>foo</code> is a generative function, we can invoke <code>foo</code> from within the body of a <code>@gen</code> function using regular call syntax. The random choices made within the call are not given addresses in our trace, and are therefore <em>untraced</em> random choices (see <a href="ref/@ref">Generative Function Interface</a> for details on untraced random choices).</p><pre><code class="language-julia">val = foo(0.5)</code></pre><p><strong>Traced call with a nested address namespace</strong>: We can include the traced random choices made by <code>foo</code> in the caller&#39;s trace, under a namespace, using <code>@trace</code>:</p><pre><code class="language-julia">val = @trace(foo(0.5), :x)</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace, under the namespace <code>:x</code>. For example, if <code>foo</code> makes random choices at addresses <code>:a</code> and <code>:b</code>, these choices will have addresses <code>:x =&gt; :a</code> and <code>:x =&gt; :b</code> in the caller&#39;s trace.</p><p><strong>Traced call with shared address namespace</strong>: We can include the traced random choices made by <code>foo</code> in the caller&#39;s trace using <code>@trace</code>:</p><pre><code class="language-julia">val = @trace(foo(0.5))</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace. The caller must guarantee that there are no address collisions. NOTE: This type of call can only be used when calling other <code>@gen</code> functions. Other types of generative functions cannot be called in this way.</p><h2><a class="nav-anchor" id="Composite-addresses-1" href="#Composite-addresses-1">Composite addresses</a></h2><p>In Julia, <code>Pair</code> values can be constructed using the <code>=&gt;</code> operator. For example, <code>:a =&gt; :b</code> is equivalent to <code>Pair(:a, :b)</code> and <code>:a =&gt; :b =&gt; :c</code> is equivalent to <code>Pair(:a, Pair(:b, :c))</code>. A <code>Pair</code> value (e.g. <code>:a =&gt; :b =&gt; :c</code>) can be passed as the address field in an <code>@trace</code> expression, provided that there is not also a random choice or generative function called with <code>@trace</code> at any prefix of the address.</p><p>Consider the following examples.</p><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(normal(0, 1), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(normal(0, 1), :a)</code></pre><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a)
@trace(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b)
@trace(normal(0, 1), :a =&gt; :c)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b)
@trace(foo(0.5), :a =&gt; :c)</code></pre><h2><a class="nav-anchor" id="Return-value-1" href="#Return-value-1">Return value</a></h2><p>Like regular Julia functions, <code>@gen</code> functions return either the expression used in a <code>return</code> keyword, or by evaluating the last expression in the function body. Note that the return value of a <code>@gen</code> function is different from a trace of <code>@gen</code> function, which contains the return value associated with an execution as well as the assignment to each random choice made during the execution. See <a href="ref/@ref">Generative Function Interface</a> for more information about traces.</p><h2><a class="nav-anchor" id="Trainable-parameters-1" href="#Trainable-parameters-1">Trainable parameters</a></h2><p>A <code>@gen</code> function may begin with an optional block of <em>trainable parameter declarations</em>. The block consists of a sequence of statements, beginning with <code>@param</code>, that declare the name and Julia type for each trainable parameter. The function below has a single trainable parameter <code>theta</code> with type <code>Float64</code>:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    @param theta::Float64
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(theta), :b)
    return z1 || z2
end</code></pre><p>Trainable parameters obey the same scoping rules as Julia local variables defined at the beginning of the function body. The value of a trainable parameter is undefined until it is initialized using <a href="#Gen.init_param!"><code>init_param!</code></a>. In addition to the current value, each trainable parameter has a current <strong>gradient accumulator</strong> value. The gradent accumulator value has the same shape (e.g. array dimension) as the parameter value. It is initialized to all zeros, and is incremented by <a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a>.</p><p>The following methods are exported for the trainable parameters of <code>@gen</code> functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.init_param!" href="#Gen.init_param!"><code>Gen.init_param!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">init_param!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol, value)</code></pre><p>Initialize the the value of a named trainable parameter of a generative function.</p><p>Also generates the gradient accumulator for that parameter to <code>zero(value)</code>.</p><p>Example:</p><pre><code class="language-julia">init_param!(foo, :theta, 0.6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/builtin_optimization.jl#L48-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_param" href="#Gen.get_param"><code>Gen.get_param</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_param(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Get the current value of a trainable parameter of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/builtin_optimization.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_param_grad" href="#Gen.get_param_grad"><code>Gen.get_param_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_param_grad(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Get the current value of the gradient accumulator for a trainable parameter of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/builtin_optimization.jl#L21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_param!" href="#Gen.set_param!"><code>Gen.set_param!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_param!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol, value)</code></pre><p>Set the value of a trainable parameter of the generative function.</p><p>NOTE: Does not update the gradient accumulator value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/builtin_optimization.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.zero_param_grad!" href="#Gen.zero_param_grad!"><code>Gen.zero_param_grad!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zero_param_grad!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Reset the gradient accumlator for a trainable parameter of the generative function to all zeros.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/builtin_optimization.jl#L30-L34">source</a></section><p>Trainable parameters are designed to be trained using gradient-based methods. This is discussed in the next section.</p><h2><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h2><p>Given a trace of a <code>@gen</code> function, Gen supports automatic differentiation of the log probability (density) of all of the random choices made in the trace with respect to the following types of inputs:</p><ul><li><p>all or a subset of the arguments to the function.</p></li><li><p>the values of all or a subset of random choices.</p></li><li><p>all or a subset of trainable parameters of the <code>@gen</code> function.</p></li></ul><p>We first discuss the semantics of these gradient computations, and then discuss what how to write and use Julia code in the body of a <code>@gen</code> function so that it can be automatically differentiated by the gradient computation.</p><h3><a class="nav-anchor" id="Supported-gradient-computations-1" href="#Supported-gradient-computations-1">Supported gradient computations</a></h3><p><strong>Gradients with respect to arguments.</strong> A <code>@gen</code> function may have a fixed set of its arguments annotated with <code>grad</code>, which indicates that gradients with respect to that argument should be supported. For example, in the function below, we indicate that we want to support differentiation with respect to the <code>y</code> argument, but that we do not want to support differentiation with respect to the <code>x</code> argument.</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        @trace(normal(y, 1), :z)
    else
        @trace(normal(y, 10), :z)
    end
end</code></pre><p>For the function <code>foo</code> above, when <code>x &gt; 5</code>, the gradient with respect to <code>y</code> is the gradient of the log probability density of a normal distribution with standard deviation 1, with respect to its mean, evaluated at mean <code>y</code>. When <code>x &lt;= 5</code>, we instead differentiate the log density of a normal distribution with standard deviation 10, relative to its mean.</p><p><strong>Gradients with respect to values of random choices.</strong> The author of a <code>@gen</code> function also identifies a set of addresses of random choices with respect to which they wish to support gradients of the log probability (density). Gradients of the log probability (density) with respect to the values of random choices are used in gradient-based numerical optimization of random choices, as well as certain MCMC updates that require gradient information.</p><p><strong>Gradients with respect to trainable parameters.</strong> The gradient of the log probability (density) with respect to the trainable parameters can also be computed using automatic differentiation. Currently, the log probability (density) must be a differentiable function of all trainable parameters.</p><p><strong>Gradients of a function of the return value.</strong> Differentiable programming in Gen composes across function calls. If the return value of the <code>@gen</code> function is conditionally dependent on source elements including (i) any arguments annotated with <code>grad</code> or (ii) any random choices for which gradients are supported, or (ii) any trainable parameters, then the gradient computation requires a gradient of the an external function with respect to the return value in order to the compute the correct gradients. Thus, the function being differentiated always includes a term representing the log probability (density) of all random choices made by the function, but can be extended with a term that depends on the return value of the function. The author of a <code>@gen</code> function can indicate that the return value depends on the source elements (causing the gradient with respect to the return value is required for all gradient computations) by adding the <code>grad</code> annotation to the <code>@gen</code> function itself. For example, in the function below, the return value is conditionally dependent (and actually identical to) on the random value at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        return @trace(normal(y, 1), :z)
    else
        return @trace(normal(y, 10), :z)
    end
end</code></pre><p>If the author of <code>foo</code> wished to support the computation of gradients with respect to the value of <code>:z</code>, they would need to add the <code>grad</code> annotation to <code>foo</code> using the following syntax:</p><pre><code class="language-julia">@gen (grad) function foo(x, (grad)(y))
    if x &gt; 5
        return @trace(normal(y, 1), :z)
    else
        return @trace(normal(y, 10), :z)
    end
end</code></pre><h3><a class="nav-anchor" id="Writing-differentiable-code-1" href="#Writing-differentiable-code-1">Writing differentiable code</a></h3><p>In order to compute the gradients described above, the code in the body of the <code>@gen</code> function needs to be differentiable. Code in the body of a <code>@gen</code> function consists of:</p><ul><li><p>Julia code</p></li><li><p>Making random choices</p></li><li><p>Calling generative functions</p></li></ul><p>We now discuss how to ensure that code of each of these forms is differentiable. Note that the procedures for differentiation of code described below are only performed during certain operations on <code>@gen</code> functions (<a href="../gfi/#Gen.choice_gradients"><code>choice_gradients</code></a> and <a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a>).</p><p><strong>Julia code.</strong> Julia code used within a body of a <code>@gen</code> function is made differentiable using the <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> package, which implements  reverse-mode automatic differentiation. Specifically, values whose gradient is required (either values of arguments, random choices, or trainable parameters) are &#39;tracked&#39; by boxing them into special values and storing the tracked value on a &#39;tape&#39;. For example a <code>Float64</code> value is boxed into a <code>ReverseDiff.TrackedReal</code> value. Methods (including e.g. arithmetic operators) are defined that operate on these tracked values and produce other tracked values as a result. As the computation proceeds all the values are placed onto the tape, with back-references to the parent operation and operands. Arithmetic operators, array and linear algebra functions, and common special numerical functions, as well as broadcasting, are automatically supported. See <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> for more details.</p><p><strong>Making random choices.</strong> When making a random choice, each argument is either a tracked value or not. If the argument is a tracked value, then the probability distribution must support differentiation of the log probability (density) with respect to that argument. Otherwise, an error is thrown. The <a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a> function indicates which arguments support differentiation for a given distribution (see <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a>). If the gradient is required for the <em>value</em> of a random choice, the distribution must support differentiation of the log probability (density) with respect to the value. This is indicated by the <a href="../distributions/#Gen.has_output_grad"><code>has_output_grad</code></a> function.</p><p><strong>Calling generative functions.</strong> Like distributions, generative functions indicate which of their arguments support differentiation, using the <code>has_argument_grads</code> function. It is an error if a tracked value is passed as an argument of a generative function, when differentiation is not supported by the generative function for that argument. If a generative function <code>gen_fn</code> has <code>accepts_output_grad(gen_fn) = true</code>, then the return value of the generative function call will be tracked and will propagate further through the caller <code>@gen</code> function&#39;s computation.</p><h2><a class="nav-anchor" id="Static-Modeling-Language-1" href="#Static-Modeling-Language-1">Static Modeling Language</a></h2><p>The <em>static modeling language</em> is a restricted variant of the built-in modeling language. Models written in the static modeling language can result in better inference performance (more inference operations per second and less memory consumption), than the full built-in modeling language, especially for models used with iterative inference algorithms like Markov chain Monte Carlo.</p><p>A function is identified as using the static modeling language by adding the <code>static</code> annotation to the function. For example:</p><pre><code class="language-julia">@gen (static) function foo(prob::Float64)
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(prob), :b)
    z3 = z1 || z2
    z4 = !z3
    return z4
end</code></pre><p>After running this code, <code>foo</code> is a Julia value whose type is a subtype of <code>StaticIRGenerativeFunction</code>, which is a subtype of <a href="../gfi/#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>.</p><h3><a class="nav-anchor" id="Static-computation-graph-1" href="#Static-computation-graph-1">Static computation graph</a></h3><p>Using the <code>static</code> annotation instructs Gen to statically construct a directed acyclic graph for the computation represented by the body of the function. For the function <code>foo</code> above, the static graph looks like:</p><div style="text-align:center">
    <img src="../../images/static_graph.png" alt="example static computation graph" width="50%"/>
</div><p>In this graph, oval nodes represent random choices, square nodes represent Julia computations, and diamond nodes represent arguments. The light blue shaded node is the return value of the function. Having access to the static graph allows Gen to generate specialized code for <a href="ref/@ref">Trace update operations</a> that skips unecessary parts of the computation. Specifically, when applying an update operation, a the graph is analyzed, and each value in the graph identified as having possibly changed, or not. Nodes in the graph do not need to be re-executed if none of their input values could have possibly changed. Also, even if some inputs to a generative function node may have changed, knowledge that some of the inputs have not changed often allows the generative function being called to more efficiently perform its update operation. This is the case for functions produced by <a href="../combinators/#Generative-Function-Combinators-1">Generative Function Combinators</a>.</p><p>You can plot the graph for a function with the <code>static</code> annotation if you have PyCall installed, and a Python environment that contains the <a href="https://pypi.org/project/graphviz/">graphviz</a> Python package, using, e.g.:</p><pre><code class="language-julia">using PyCall
@pyimport graphviz
using Gen: draw_graph
draw_graph(foo, graphviz, &quot;test&quot;)</code></pre><p>This will produce a file <code>test.pdf</code> in the current working directory containing the rendered graph.</p><h3><a class="nav-anchor" id="Restrictions-1" href="#Restrictions-1">Restrictions</a></h3><p>In order to be able to construct the static graph, Gen restricts the permitted syntax that can be used in functions annotated with <code>static</code>. In particular, each statement in the body must be one of the following:</p><ul><li>A pure functional Julia expression on the right-hand side, and a symbol on the left-hand side, e.g.:</li></ul><pre><code class="language-julia">z4 = !z3</code></pre><ul><li>A <code>@trace</code> expression on the right-hand side, and a symbol on the left-hand side, e.g.:</li></ul><pre><code class="language-julia">z2 = @trace(bernoulli(prob), :b)</code></pre><p>The trace statement must use a literal Julia symbol for the first component in the address. Unlike the full built-in modeling-language, the address is not optional.</p><ul><li>A <code>return</code> statement, with a literal Julia symbol on the right-hand side, e.g.:</li></ul><pre><code class="language-julia">return z4</code></pre><p>The functions must also satisfy the following rules: </p><ul><li><p><code>@trace</code> expressions cannot appear anywhere in the function body except for as the outer-most expression on the right-hand side of a statement.</p></li><li><p>Each literal symbol used in the left-hand side of a statement must be unique (e.g. you cannot re-assign to a variable).</p></li><li><p>Julia closures and list comprehensions are not allowed.</p></li><li><p>For composite addresses (e.g. <code>:a =&gt; 2 =&gt; :c</code>) the first component of the address must be a literal symbol, and there may only be one statement in the function body that uses this symbol for the first component of its address.</p></li><li><p>Julia control flow constructs (e.g. <code>if</code>, <code>for</code>, <code>while</code>) cannot be used as top-level statements in the function body. Control flow should be implemented inside Julia functions that are called, generative functions that are called such as generative functions produced using <a href="../combinators/#Generative-Function-Combinators-1">Generative Function Combinators</a>.</p></li></ul><h3><a class="nav-anchor" id="Loading-generated-functions-1" href="#Loading-generated-functions-1">Loading generated functions</a></h3><p>Before a function with a static annotation can be used, the <a href="#Gen.load_generated_functions"><code>load_generated_functions</code></a> method must be called:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.load_generated_functions" href="#Gen.load_generated_functions"><code>Gen.load_generated_functions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_generated_functions()</code></pre><p>Permit use of generative functions written in the static modeling language up to this point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/f297e0b981f8d9969a676767514c1de761b3d40d/src/Gen.jl#L7-L11">source</a></section><p>Typically, one call to this function, at the top level of a script, separates the definition of generative functions from the execution of inference code, e.g.:</p><pre><code class="language-julia">using Gen: load_generated_functions

# define generative functions and inference code
..

# allow static generative functions defined above to be used
load_generated_functions()

# run inference code
..</code></pre><h3><a class="nav-anchor" id="Performance-tips-1" href="#Performance-tips-1">Performance tips</a></h3><p>For better performance when the arguments are simple data types like <code>Float64</code>, annotate the arguments with the concrete type. This permits a more optimized trace data structure to be generated for the generative function.</p><footer><hr/><a class="previous" href="../distributions/"><span class="direction">Previous</span><span class="title">Probability Distributions</span></a><a class="next" href="../combinators/"><span class="direction">Next</span><span class="title">Generative Function Combinators</span></a></footer></article></body></html>
