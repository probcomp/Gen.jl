<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Function Combinators · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Language and API Reference</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li class="current"><a class="toctext" href>Generative Function Combinators</a><ul class="internal"><li><a class="toctext" href="#Map-combinator-1">Map combinator</a></li><li><a class="toctext" href="#Unfold-combinator-1">Unfold combinator</a></li><li><a class="toctext" href="#Recurse-combinator-1">Recurse combinator</a></li></ul></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Generative Function Combinators</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/combinators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Function Combinators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Function-Combinators-1" href="#Generative-Function-Combinators-1">Generative Function Combinators</a></h1><p>Generative function combinators are Julia functions that take one or more generative functions as input and return a new generative function. Generative function combinators are used to express patterns of repeated computation that appear frequently in generative models. Some generative function combinators are similar to higher order functions from functional programming languages. However, generative function combinators are not &#39;higher order generative functions&#39;, because they are not themselves generative functions (they are regular Julia functions).</p><h2><a class="nav-anchor" id="Map-combinator-1" href="#Map-combinator-1">Map combinator</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.Map" href="#Gen.Map"><code>Gen.Map</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">gen_fn = Map(kernel::GenerativeFunction)</code></pre><p>Return a new generative function that applies the kernel independently for a vector of inputs.</p><p>The returned generative function has one argument with type <code>Vector{X}</code> for each argument of the input generative function with type <code>X</code>. The length of each argument, which must be the same for each argument, determines the number of times the input generative function is called (N). Each call to the input function is made under address namespace i for i=1..N. The return value of the returned function has type <code>FunctionalCollections.PersistentVector{Y}</code> where <code>Y</code> is the type of the return value of the input function. The map combinator is similar to the &#39;map&#39; higher order function in functional programming, except that the map combinator returns a new generative function that must then be separately applied.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/73409ae2af5369b3e6661cbf9bd29aa3592280cd/src/combinators/map/map.jl#L8-L18">source</a></section><p>In the schematic below, the kernel is denoted <span>$\mathcal{G}_{\mathrm{k}}$</span>.</p><div style="text-align:center">
    <img src="../../images/map_combinator.png" alt="schematic of map combinator" width="50%"/>
</div><p>For example, consider the following generative function, which makes one random choice at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(x1::Float64, x2::Float64)
    y = @addr(normal(x1 + x2, 1.0), :z)
    return y
end</code></pre><p>We apply the map combinator to produce a new generative function <code>bar</code>:</p><pre><code class="language-julia">bar = Map(foo)</code></pre><p>We can then obtain a trace of <code>bar</code>:</p><pre><code class="language-julia">(trace, _) = initialize(bar, ([0.0, 0.5], [0.5, 1.0]))</code></pre><p>This causes <code>foo</code> to be invoked twice, once with arguments <code>(0.0, 0.5)</code> in address namespace <code>1</code> and once with arguments <code>(0.5, 1.0)</code> in address namespace <code>2</code>. If the resulting trace has random choices:</p><pre><code class="language-none">│
├── 1
│   │
│   └── :z : -0.5757913836706721
│
└── 2
    │
    └── :z : 0.7357177113395333</code></pre><p>then the return value is:</p><pre><code class="language-none">FunctionalCollections.PersistentVector{Any}[-0.575791, 0.735718]</code></pre><h3><a class="nav-anchor" id="Argdiffs-1" href="#Argdiffs-1">Argdiffs</a></h3><p>Generative functions produced by this combinator accept the following argdiff types:</p><ul><li><p><a href="../gfi/#Gen.NoArgDiff"><code>NoArgDiff</code></a></p></li><li><p><a href="../gfi/#Gen.UnknownArgDiff"><code>UnknownArgDiff</code></a></p></li><li><p><a href="#Gen.MapCustomArgDiff"><code>MapCustomArgDiff</code></a></p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.MapCustomArgDiff" href="#Gen.MapCustomArgDiff"><code>Gen.MapCustomArgDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">argdiff = MapCustomArgDiff{T}(retained_argdiffs::Dict{Int,T})</code></pre><p>Construct an argdiff value that contains argdiff information for some subset of applications of the kernel.</p><p>If the number of applications of the kernel, which is determined from the the length of hte input vector(s), has changed, then <code>retained_argdiffs</code> may only contain argdiffs for kernel applications that exist both in the previous trace and and the new trace. For each <code>i</code> in <code>keys(retained_argdiffs)</code>, <code>retained_argdiffs[i]</code> contains the argdiff information for the <code>i</code>th application. If an entry is not provided for some <code>i</code> that exists in both the previous and new traces, then its argdiff will be assumed to be <a href="../gfi/#Gen.NoArgDiff"><code>NoArgDiff</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/73409ae2af5369b3e6661cbf9bd29aa3592280cd/src/combinators/map/map.jl#L43-L51">source</a></section><h3><a class="nav-anchor" id="Retdiffs-1" href="#Retdiffs-1">Retdiffs</a></h3><p>Generative functions produced by this combinator may return retdiffs that are one of the following types:</p><ul><li><p><a href="../gfi/#Gen.NoRetDiff"><code>NoRetDiff</code></a></p></li><li><p><a href="#Gen.VectorCustomRetDiff"><code>VectorCustomRetDiff</code></a></p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.VectorCustomRetDiff" href="#Gen.VectorCustomRetDiff"><code>Gen.VectorCustomRetDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">retdiff = VectorCustomRetDiff(retained_retdiffs:Dict{Int,Any})</code></pre><p>Construct a retdiff that provides retdiff information about some elements of the returned vector.</p><pre><code class="language-none">retdiff[i]</code></pre><p>Return the retdiff value for the <code>i</code>th element of the vector.</p><pre><code class="language-none">haskey(retdiff, i::Int)</code></pre><p>Return true if there is a retdiff value for the <code>i</code>th element of the vector, or false if there was no difference in this element.</p><pre><code class="language-none">keys(retdiff)</code></pre><p>Return an iterator over the elements with retdiff values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/73409ae2af5369b3e6661cbf9bd29aa3592280cd/src/combinators/vector.jl#L123-L139">source</a></section><h2><a class="nav-anchor" id="Unfold-combinator-1" href="#Unfold-combinator-1">Unfold combinator</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.Unfold" href="#Gen.Unfold"><code>Gen.Unfold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">gen_fn = Unfold(kernel::GenerativeFunction)</code></pre><p>Return a new generative function that applies the kernel in sequence, passing the return value of one application as an input to the next.</p><p>The kernel accepts the following arguments:</p><ul><li><p>The first argument is the <code>Int</code> index indicating the position in the sequence (starting from 1).</p></li><li><p>The second argument is the <em>state</em>.</p></li><li><p>The kernel may have additional arguments after the state.</p></li></ul><p>The return type of the kernel must be the same type as the state.</p><p>The returned generative function accepts the following arguments:</p><ul><li><p>The number of times (N) to apply the kernel.</p></li><li><p>The initial state.</p></li><li><p>The rest of the arguments (not including the state) that will be passed to each kernel application.</p></li></ul><p>The return type of the returned generative function is <code>FunctionalCollections.PersistentVector{T}</code> where <code>T</code> is the return type of the kernel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/73409ae2af5369b3e6661cbf9bd29aa3592280cd/src/combinators/unfold/unfold.jl#L5-L29">source</a></section><p>In the schematic below, the kernel is denoted <span>$\mathcal{G}_{\mathrm{k}}$</span>. The initial state is denoted <span>$y_0$</span>, the number of applications is <span>$n$</span>, and the remaining arguments to the kernel not including the state, are <span>$z$</span>.</p><div style="text-align:center">
    <img src="../../images/unfold_combinator.png" alt="schematic of unfold combinator" width="70%"/>
</div><p>For example, consider the following kernel, with state type <code>Bool</code>, which makes one random choice at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(t::Int, y_prev::Bool, z1::Float64, z2::Float64)
    y = @addr(bernoulli(y_prev ? z1 : z2), :y)
    return y
end</code></pre><p>We apply the map combinator to produce a new generative function <code>bar</code>:</p><pre><code class="language-julia">bar = Map(foo)</code></pre><p>We can then obtain a trace of <code>bar</code>:</p><pre><code class="language-julia">(trace, _) = initialize(bar, (5, false, 0.05, 0.95))</code></pre><p>This causes <code>foo</code> to be invoked five times. The resulting trace may contain the following random choices:</p><pre><code class="language-none">│
├── 1
│   │
│   └── :y : true
│
├── 2
│   │
│   └── :y : false
│
├── 3
│   │
│   └── :y : true
│
├── 4
│   │
│   └── :y : false
│
└── 5
    │
    └── :y : true
</code></pre><p>then the return value is:</p><pre><code class="language-none">FunctionalCollections.PersistentVector{Any}[true, false, true, false, true]</code></pre><h3><a class="nav-anchor" id="Argdiffs-2" href="#Argdiffs-2">Argdiffs</a></h3><p>Generative functions produced by this combinator accept the following argdiff types:</p><ul><li><p><a href="../gfi/#Gen.NoArgDiff"><code>NoArgDiff</code></a></p></li><li><p><a href="../gfi/#Gen.UnknownArgDiff"><code>UnknownArgDiff</code></a></p></li><li><p><a href="#Gen.UnfoldCustomArgDiff"><code>UnfoldCustomArgDiff</code></a></p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.UnfoldCustomArgDiff" href="#Gen.UnfoldCustomArgDiff"><code>Gen.UnfoldCustomArgDiff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">argdiff = UnfoldCustomArgDiff(init_changed::Bool, params_changed::Bool)</code></pre><p>Construct an argdiff that indicates whether the initial state may have changed (<code>init_changed</code>) , and whether or not the remaining arguments to the kernel may have changed (<code>params_changed</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/73409ae2af5369b3e6661cbf9bd29aa3592280cd/src/combinators/unfold/unfold.jl#L43-L47">source</a></section><h3><a class="nav-anchor" id="Retdiffs-2" href="#Retdiffs-2">Retdiffs</a></h3><p>Generative functions produced by this combinator may return retdiffs that are one of the following types:</p><ul><li><p><a href="../gfi/#Gen.NoRetDiff"><code>NoRetDiff</code></a></p></li><li><p><a href="#Gen.VectorCustomRetDiff"><code>VectorCustomRetDiff</code></a></p></li></ul><h2><a class="nav-anchor" id="Recurse-combinator-1" href="#Recurse-combinator-1">Recurse combinator</a></h2><p>TODO: document me</p><div style="text-align:center">
    <img src="../../images/recurse_combinator.png" alt="schematic of recurse combinatokr" width="70%"/>
</div><footer><hr/><a class="previous" href="../modeling/"><span class="direction">Previous</span><span class="title">Built-in Modeling Language</span></a><a class="next" href="../assignments/"><span class="direction">Next</span><span class="title">Assignments</span></a></footer></article></body></html>
