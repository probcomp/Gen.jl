<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in Modeling Language · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Modeling Languages and APIs</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li class="current"><a class="toctext" href>Built-in Modeling Language</a><ul class="internal"><li><a class="toctext" href="#Annotations-1">Annotations</a></li><li><a class="toctext" href="#Making-random-choices-1">Making random choices</a></li><li><a class="toctext" href="#Calling-generative-functions-1">Calling generative functions</a></li><li><a class="toctext" href="#Composite-addresses-1">Composite addresses</a></li><li><a class="toctext" href="#Return-value-1">Return value</a></li><li><a class="toctext" href="#Trainable-parameters-1">Trainable parameters</a></li><li><a class="toctext" href="#Differentiable-programming-1">Differentiable programming</a></li><li><a class="toctext" href="#Static-Modeling-Language-1">Static Modeling Language</a></li></ul></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../extending/">Extending Gen</a></li></ul></li><li><span class="toctext">Standard Inference Library</span><ul><li><a class="toctext" href="../importance/">Importance Sampling</a></li><li><a class="toctext" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../pf/">Particle Filtering</a></li><li><a class="toctext" href="../vi/">Variational Inference</a></li><li><a class="toctext" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modeling Languages and APIs</li><li><a href>Built-in Modeling Language</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/modeling.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Built-in Modeling Language</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Built-in-Modeling-Language-1" href="#Built-in-Modeling-Language-1">Built-in Modeling Language</a></h1><p>Gen provides a built-in embedded modeling language for defining generative functions. The language uses a syntax that extends Julia&#39;s syntax for defining regular Julia functions.</p><p>Generative functions in the modeling language are identified using the <code>@gen</code> keyword in front of a Julia function definition. Here is an example <code>@gen</code> function that samples two random choices:</p><pre><code class="language-julia">@gen function foo(prob::Float64=0.1)
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(prob), :b)
    return z1 || z2
end</code></pre><p>After running this code, <code>foo</code> is a Julia value of type <a href="#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.DynamicDSLFunction" href="#Gen.DynamicDSLFunction"><code>Gen.DynamicDSLFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicDSLFunction{T} &lt;: GenerativeFunction{T,DynamicDSLTrace}</code></pre><p>A generative function based on a shallowly embedding modeling language based on Julia functions.</p><p>Constructed using the <code>@gen</code> keyword. Most methods in the generative function interface involve a end-to-end execution of the function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/dynamic/dynamic.jl#L3-L10">source</a></section><p>Note that it is possible to provide default values for trailing positional arguments. However, keyword arguments are currently <em>not</em> supported.</p><p>We can call the resulting generative function like we would a regular Julia function:</p><pre><code class="language-julia">retval::Bool = foo(0.5)</code></pre><p>We can also trace its execution:</p><pre><code class="language-julia">(trace, _) = generate(foo, (0.5,))</code></pre><p>Optional arguments can be left out of the above operations, and default values will be filled in automatically:</p><pre><code class="language-julia">julia&gt; (trace, _) = generate(foo, (,));
julia&gt; get_args(trace)
(0.1,)</code></pre><p>See <a href="../gfi/#Generative-Functions-1">Generative Functions</a> for the full set of operations supported by a generative function. Note that the built-in modeling language described in this section is only one of many ways of defining a generative function – generative functions can also be constructed using other embedded languages, or by directly implementing the methods of the generative function interface. However, the built-in modeling language is intended to being flexible enough cover a wide range of use cases. In the remainder of this section, we refer to generative functions defined using the built-in modeling language as <code>@gen</code> functions.</p><h2><a class="nav-anchor" id="Annotations-1" href="#Annotations-1">Annotations</a></h2><p>Annotations are a syntactic construct in the built-in modeling language that allows users to provide additional information about how <code>@gen</code> functions should be interpreted. Annotations are optional, and not necessary to understand the basics of Gen. There are two types of annotations – <em>argument annotations</em> and <em>function annotations</em>.</p><p><strong>Argument annotations.</strong> In addition to type declarations on arguments like regular Julia functions, <code>@gen</code> functions also support additional annotations on arguments. Each argument can have the following different syntactic forms:</p><ul><li><p><code>y</code>: No type declaration; no annotations.</p></li><li><p><code>y::Float64</code>: Type declaration; but no annotations.</p></li><li><p><code>(grad)(y)</code>: No type declaration provided;, annotated with <code>grad</code>.</p></li><li><p><code>(grad)(y::Float64)</code>: Type declaration provided; and annotated with <code>grad</code>.</p></li></ul><p>Currently, the possible argument annotations are:</p><ul><li><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</li></ul><p><strong>Function annotations.</strong> The <code>@gen</code> function itself can also be optionally associated with zero or more annotations, which are separate from the per-argument annotations. Function-level annotations use the following different syntactic forms:</p><ul><li><p><code>@gen function foo(&lt;args&gt;) &lt;body&gt; end</code>: No function annotations.</p></li><li><p><code>@gen (grad) function foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has the <code>grad</code> annotation.</p></li><li><p><code>@gen (grad,static) function foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has both the <code>grad</code> and <code>static</code> annotations.</p></li></ul><p>Currently the possible function annotations are:</p><ul><li><p><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</p></li><li><p><code>static</code> (see <a href="#Static-Modeling-Language-1">Static Modeling Language</a>).</p></li><li><p><code>nojuliacache</code> (see <a href="#Static-Modeling-Language-1">Static Modeling Language</a>).</p></li></ul><h2><a class="nav-anchor" id="Making-random-choices-1" href="#Making-random-choices-1">Making random choices</a></h2><p>Random choices are made by calling a probability distribution on some arguments:</p><pre><code class="language-julia">val::Bool = bernoulli(0.5)</code></pre><p>See <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a> for the set of built-in probability distributions, and for information on implementing new probability distributions.</p><p>In the body of a <code>@gen</code> function, wrapping a call to a random choice with an <code>@trace</code> expression associates the random choice with an <em>address</em>, and evaluates to the value of the random choice. The syntax is:</p><pre><code class="language-julia">@trace(&lt;distribution&gt;(&lt;args&gt;), &lt;addr&gt;)</code></pre><p>Addresses can be any Julia value. Here, we give the Julia symbol address <code>:z</code> to a Bernoulli random choice.</p><pre><code class="language-julia">val::Bool = @trace(bernoulli(0.5), :z)</code></pre><p>Not all random choices need to be given addresses. An address is required if the random choice will be observed, or will be referenced by a custom inference algorithm (e.g. if it will be proposed to by a custom proposal distribution).</p><h3><a class="nav-anchor" id="Sample-space-and-support-of-random-choices-1" href="#Sample-space-and-support-of-random-choices-1">Sample space and support of random choices</a></h3><p>Different probability distributions produce different types of values for their random choices. For example, the <a href="../distributions/#Gen.bernoulli"><code>bernoulli</code></a> distribution results in <code>Bool</code> values (either <code>true</code> or <code>false</code>), the <a href="../distributions/#Gen.normal"><code>normal</code></a> distribution results in <code>Real</code> values that may be positive or negative, and the <a href="../distributions/#Gen.beta"><code>beta</code></a> distribution result in <code>Real</code> values that are always in the unit interval (0, 1).</p><p>Each <code>Distribution</code> is associated with two sets of values:</p><ul><li><p>The <strong>sample space</strong> of the distribution, which does not depend on the arguments.</p></li><li><p>The <strong>support</strong> of the distribution, which may depend on the arguments, and is the set of values that has nonzero probability (or probability density). It may be the entire sample space, or it may be a subset of the sample space.</p></li></ul><p>For example, the sample space of <a href="../distributions/#Gen.bernoulli"><code>bernoulli</code></a> is <code>Bool</code> and its support is either <code>{true}</code>, <code>{false}</code>, or <code>{true, false}</code>. The sample space of <a href="../distributions/#Gen.normal"><code>normal</code></a> is <code>Real</code> and its support is the set of all values on the real line. The sample space of <a href="../distributions/#Gen.beta"><code>beta</code></a> is <code>Real</code> and its support is the set of values in the interval (0, 1).</p><p>Gen&#39;s built in modeling languages require that a address is associated with a fixed sample space. For example, it is not permitted to use a <code>bernoulli</code> distribution to sample at addresss <code>:a</code> in one execution, and a <code>normal</code> distribution to sample at address <code>:a</code> in a different execution, because their sample spaces differ (<code>Bool</code> vs <code>Real</code>):</p><pre><code class="language-julia">@gen function foo()
    if @trace(bernoulli(0.5), :branch)
        @trace(bernoulli(0.5), :x)
    else
        @trace(normal(0, 1), :x)
    end
end</code></pre><p>A generative function can be <strong>disciplined</strong> or not. In a disciplined generative function, the support of random choices at each address must be fixed. That is, for each address <code>a</code> there must exist a set S that is a subset of the sample space such that for all executions of the generative function, if <code>a</code> occurs as the address of a choice in the execution, then the support of that choice is exactly S. Violating this discipline will cause NaNs, errors, or undefined behavior in some inference programs. However, in many cases it is convenient to write an inference program that operates correctly and efficiently on some specialized class of undisciplined models. In these cases, authors who want their inference code to be reusable should consider documenting which kinds of undisciplined models their inference algorithms allow or expect to see.</p><p>If the support of a random choice needs to change, a disciplined generative function can represent this by using a different address for each distinct value of the support. For example, consider the following generative function:</p><pre><code class="language-julia">@gen function foo()
    n = @trace(categorical([0.5, 0.5]), :n) + 1
    @trace(categorical(ones(n) / n), :x)
end</code></pre><p>The support of the random choice with address <code>:x</code> is either the set <span>$\{1, 2\}$</span> or <span>$\{1, 2, 3\}$</span>. Therefore, this random choice does not have constant support, and the generative function <code>foo</code> is not &#39;disciplined&#39;. Specifically, this could result in undefined behavior for the following inference program:</p><pre><code class="language-julia">tr, _ = importance_resampling(foo, (), choicemap((:x, 3)))</code></pre><p>It is recommended to write disciplined generative functions when possible.</p><h2><a class="nav-anchor" id="Calling-generative-functions-1" href="#Calling-generative-functions-1">Calling generative functions</a></h2><p><code>@gen</code> functions can invoke other generative functions in three ways:</p><p><strong>Untraced call</strong>: If <code>foo</code> is a generative function, we can invoke <code>foo</code> from within the body of a <code>@gen</code> function using regular call syntax. The random choices made within the call are not given addresses in our trace, and are therefore <em>untraced</em> random choices (see <a href="ref/@ref">Generative Function Interface</a> for details on untraced random choices).</p><pre><code class="language-julia">val = foo(0.5)</code></pre><p><strong>Traced call with a nested address namespace</strong>: We can include the traced random choices made by <code>foo</code> in the caller&#39;s trace, under a namespace, using <code>@trace</code>:</p><pre><code class="language-julia">val = @trace(foo(0.5), :x)</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace, under the namespace <code>:x</code>. For example, if <code>foo</code> makes random choices at addresses <code>:a</code> and <code>:b</code>, these choices will have addresses <code>:x =&gt; :a</code> and <code>:x =&gt; :b</code> in the caller&#39;s trace.</p><p><strong>Traced call with shared address namespace</strong>: We can include the traced random choices made by <code>foo</code> in the caller&#39;s trace using <code>@trace</code>:</p><pre><code class="language-julia">val = @trace(foo(0.5))</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace. The caller must guarantee that there are no address collisions. NOTE: This type of call can only be used when calling other <code>@gen</code> functions. Other types of generative functions cannot be called in this way.</p><h2><a class="nav-anchor" id="Composite-addresses-1" href="#Composite-addresses-1">Composite addresses</a></h2><p>In Julia, <code>Pair</code> values can be constructed using the <code>=&gt;</code> operator. For example, <code>:a =&gt; :b</code> is equivalent to <code>Pair(:a, :b)</code> and <code>:a =&gt; :b =&gt; :c</code> is equivalent to <code>Pair(:a, Pair(:b, :c))</code>. A <code>Pair</code> value (e.g. <code>:a =&gt; :b =&gt; :c</code>) can be passed as the address field in an <code>@trace</code> expression, provided that there is not also a random choice or generative function called with <code>@trace</code> at any prefix of the address.</p><p>Consider the following examples.</p><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(normal(0, 1), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(normal(0, 1), :a)</code></pre><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b =&gt; :c)
@trace(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b</code>:</p><pre><code class="language-julia">@trace(normal(0, 1), :a)
@trace(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b)
@trace(normal(0, 1), :a =&gt; :c)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@trace(normal(0, 1), :a =&gt; :b)
@trace(foo(0.5), :a =&gt; :c)</code></pre><h2><a class="nav-anchor" id="Return-value-1" href="#Return-value-1">Return value</a></h2><p>Like regular Julia functions, <code>@gen</code> functions return either the expression used in a <code>return</code> keyword, or by evaluating the last expression in the function body. Note that the return value of a <code>@gen</code> function is different from a trace of <code>@gen</code> function, which contains the return value associated with an execution as well as the assignment to each random choice made during the execution. See <a href="ref/@ref">Generative Function Interface</a> for more information about traces.</p><h2><a class="nav-anchor" id="Trainable-parameters-1" href="#Trainable-parameters-1">Trainable parameters</a></h2><p>A <code>@gen</code> function may begin with an optional block of <em>trainable parameter declarations</em>. The block consists of a sequence of statements, beginning with <code>@param</code>, that declare the name and Julia type for each trainable parameter. The function below has a single trainable parameter <code>theta</code> with type <code>Float64</code>:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    @param theta::Float64
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(theta), :b)
    return z1 || z2
end</code></pre><p>Trainable parameters obey the same scoping rules as Julia local variables defined at the beginning of the function body. The value of a trainable parameter is undefined until it is initialized using <a href="#Gen.init_param!"><code>init_param!</code></a>. In addition to the current value, each trainable parameter has a current <strong>gradient accumulator</strong> value. The gradient accumulator value has the same shape (e.g. array dimension) as the parameter value. It is initialized to all zeros, and is incremented by <a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a>.</p><p>The following methods are exported for the trainable parameters of <code>@gen</code> functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.init_param!" href="#Gen.init_param!"><code>Gen.init_param!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">init_param!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol, value)</code></pre><p>Initialize the the value of a named trainable parameter of a generative function.</p><p>Also generates the gradient accumulator for that parameter to <code>zero(value)</code>.</p><p>Example:</p><pre><code class="language-julia">init_param!(foo, :theta, 0.6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/builtin_optimization.jl#L48-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_param" href="#Gen.get_param"><code>Gen.get_param</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_param(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Get the current value of a trainable parameter of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/builtin_optimization.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_param_grad" href="#Gen.get_param_grad"><code>Gen.get_param_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_param_grad(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Get the current value of the gradient accumulator for a trainable parameter of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/builtin_optimization.jl#L21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_param!" href="#Gen.set_param!"><code>Gen.set_param!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_param!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol, value)</code></pre><p>Set the value of a trainable parameter of the generative function.</p><p>NOTE: Does not update the gradient accumulator value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/builtin_optimization.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.zero_param_grad!" href="#Gen.zero_param_grad!"><code>Gen.zero_param_grad!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zero_param_grad!(gen_fn::Union{DynamicDSLFunction,StaticIRGenerativeFunction}, name::Symbol)</code></pre><p>Reset the gradient accumlator for a trainable parameter of the generative function to all zeros.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/builtin_optimization.jl#L30-L34">source</a></section><p>Trainable parameters are designed to be trained using gradient-based methods. This is discussed in the next section.</p><h2><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h2><p>Given a trace of a <code>@gen</code> function, Gen supports automatic differentiation of the log probability (density) of all of the random choices made in the trace with respect to the following types of inputs:</p><ul><li><p>all or a subset of the arguments to the function.</p></li><li><p>the values of all or a subset of random choices.</p></li><li><p>all or a subset of trainable parameters of the <code>@gen</code> function.</p></li></ul><p>We first discuss the semantics of these gradient computations, and then discuss what how to write and use Julia code in the body of a <code>@gen</code> function so that it can be automatically differentiated by the gradient computation.</p><h3><a class="nav-anchor" id="Supported-gradient-computations-1" href="#Supported-gradient-computations-1">Supported gradient computations</a></h3><p><strong>Gradients with respect to arguments.</strong> A <code>@gen</code> function may have a fixed set of its arguments annotated with <code>grad</code>, which indicates that gradients with respect to that argument should be supported. For example, in the function below, we indicate that we want to support differentiation with respect to the <code>y</code> argument, but that we do not want to support differentiation with respect to the <code>x</code> argument.</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        @trace(normal(y, 1), :z)
    else
        @trace(normal(y, 10), :z)
    end
end</code></pre><p>For the function <code>foo</code> above, when <code>x &gt; 5</code>, the gradient with respect to <code>y</code> is the gradient of the log probability density of a normal distribution with standard deviation 1, with respect to its mean, evaluated at mean <code>y</code>. When <code>x &lt;= 5</code>, we instead differentiate the log density of a normal distribution with standard deviation 10, relative to its mean.</p><p><strong>Gradients with respect to values of random choices.</strong> The author of a <code>@gen</code> function also identifies a set of addresses of random choices with respect to which they wish to support gradients of the log probability (density). Gradients of the log probability (density) with respect to the values of random choices are used in gradient-based numerical optimization of random choices, as well as certain MCMC updates that require gradient information.</p><p><strong>Gradients with respect to trainable parameters.</strong> The gradient of the log probability (density) with respect to the trainable parameters can also be computed using automatic differentiation. Currently, the log probability (density) must be a differentiable function of all trainable parameters.</p><p><strong>Gradients of a function of the return value.</strong> Differentiable programming in Gen composes across function calls. If the return value of the <code>@gen</code> function is conditionally dependent on source elements including (i) any arguments annotated with <code>grad</code> or (ii) any random choices for which gradients are supported, or (ii) any trainable parameters, then the gradient computation requires a gradient of the an external function with respect to the return value in order to the compute the correct gradients. Thus, the function being differentiated always includes a term representing the log probability (density) of all random choices made by the function, but can be extended with a term that depends on the return value of the function. The author of a <code>@gen</code> function can indicate that the return value depends on the source elements (causing the gradient with respect to the return value is required for all gradient computations) by adding the <code>grad</code> annotation to the <code>@gen</code> function itself. For example, in the function below, the return value is conditionally dependent (and actually identical to) on the random value at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        return @trace(normal(y, 1), :z)
    else
        return @trace(normal(y, 10), :z)
    end
end</code></pre><p>If the author of <code>foo</code> wished to support the computation of gradients with respect to the value of <code>:z</code>, they would need to add the <code>grad</code> annotation to <code>foo</code> using the following syntax:</p><pre><code class="language-julia">@gen (grad) function foo(x, (grad)(y))
    if x &gt; 5
        return @trace(normal(y, 1), :z)
    else
        return @trace(normal(y, 10), :z)
    end
end</code></pre><h3><a class="nav-anchor" id="Writing-differentiable-code-1" href="#Writing-differentiable-code-1">Writing differentiable code</a></h3><p>In order to compute the gradients described above, the code in the body of the <code>@gen</code> function needs to be differentiable. Code in the body of a <code>@gen</code> function consists of:</p><ul><li><p>Julia code</p></li><li><p>Making random choices</p></li><li><p>Calling generative functions</p></li></ul><p>We now discuss how to ensure that code of each of these forms is differentiable. Note that the procedures for differentiation of code described below are only performed during certain operations on <code>@gen</code> functions (<a href="../gfi/#Gen.choice_gradients"><code>choice_gradients</code></a> and <a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a>).</p><p><strong>Julia code.</strong> Julia code used within a body of a <code>@gen</code> function is made differentiable using the <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> package, which implements  reverse-mode automatic differentiation. Specifically, values whose gradient is required (either values of arguments, random choices, or trainable parameters) are &#39;tracked&#39; by boxing them into special values and storing the tracked value on a &#39;tape&#39;. For example a <code>Float64</code> value is boxed into a <code>ReverseDiff.TrackedReal</code> value. Methods (including e.g. arithmetic operators) are defined that operate on these tracked values and produce other tracked values as a result. As the computation proceeds all the values are placed onto the tape, with back-references to the parent operation and operands. Arithmetic operators, array and linear algebra functions, and common special numerical functions, as well as broadcasting, are automatically supported. See <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> for more details.</p><p><strong>Making random choices.</strong> When making a random choice, each argument is either a tracked value or not. If the argument is a tracked value, then the probability distribution must support differentiation of the log probability (density) with respect to that argument. Otherwise, an error is thrown. The <a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a> function indicates which arguments support differentiation for a given distribution (see <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a>). If the gradient is required for the <em>value</em> of a random choice, the distribution must support differentiation of the log probability (density) with respect to the value. This is indicated by the <a href="../extending/#Gen.has_output_grad"><code>has_output_grad</code></a> function.</p><p><strong>Calling generative functions.</strong> Like distributions, generative functions indicate which of their arguments support differentiation, using the <code>has_argument_grads</code> function. It is an error if a tracked value is passed as an argument of a generative function, when differentiation is not supported by the generative function for that argument. If a generative function <code>gen_fn</code> has <code>accepts_output_grad(gen_fn) = true</code>, then the return value of the generative function call will be tracked and will propagate further through the caller <code>@gen</code> function&#39;s computation.</p><h2><a class="nav-anchor" id="Static-Modeling-Language-1" href="#Static-Modeling-Language-1">Static Modeling Language</a></h2><p>The <em>static modeling language</em> is a restricted variant of the built-in modeling language. Models written in the static modeling language can result in better inference performance (more inference operations per second and less memory consumption), than the full built-in modeling language, especially for models used with iterative inference algorithms like Markov chain Monte Carlo.</p><p>A function is identified as using the static modeling language by adding the <code>static</code> annotation to the function. For example:</p><pre><code class="language-julia">@gen (static) function foo(prob::Float64)
    z1 = @trace(bernoulli(prob), :a)
    z2 = @trace(bernoulli(prob), :b)
    z3 = z1 || z2
    z4 = !z3
    return z4
end</code></pre><p>After running this code, <code>foo</code> is a Julia value whose type is a subtype of <code>StaticIRGenerativeFunction</code>, which is a subtype of <a href="../gfi/#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>.</p><h3><a class="nav-anchor" id="Static-computation-graph-1" href="#Static-computation-graph-1">Static computation graph</a></h3><p>Using the <code>static</code> annotation instructs Gen to statically construct a directed acyclic graph for the computation represented by the body of the function. For the function <code>foo</code> above, the static graph looks like:</p><div style="text-align:center">
    <img src="../../images/static_graph.png" alt="example static computation graph" width="50%"/>
</div><p>In this graph, oval nodes represent random choices, square nodes represent Julia computations, and diamond nodes represent arguments. The light blue shaded node is the return value of the function. Having access to the static graph allows Gen to generate specialized code for <a href="../gfi/#Updating-traces-1">Updating traces</a> that skips unecessary parts of the computation. Specifically, when applying an update operation, the graph is analyzed, and each value in the graph identified as having possibly changed, or not. Nodes in the graph do not need to be re-executed if none of their input values could have possibly changed. Also, even if some inputs to a generative function node may have changed, knowledge that some of the inputs have not changed often allows the generative function being called to more efficiently perform its update operation. This is the case for functions produced by <a href="../combinators/#Generative-Function-Combinators-1">Generative Function Combinators</a>.</p><p>You can plot the graph for a function with the <code>static</code> annotation if you have PyCall installed, and a Python environment that contains the <a href="https://pypi.org/project/graphviz/">graphviz</a> Python package, using, e.g.:</p><pre><code class="language-julia">using PyCall
@pyimport graphviz
using Gen: draw_graph
draw_graph(foo, graphviz, &quot;test&quot;)</code></pre><p>This will produce a file <code>test.pdf</code> in the current working directory containing the rendered graph.</p><h3><a class="nav-anchor" id="Restrictions-1" href="#Restrictions-1">Restrictions</a></h3><p>In order to be able to construct the static graph, Gen restricts the permitted syntax that can be used in functions annotated with <code>static</code>. In particular, each statement in the body must be one of the following:</p><ul><li>A <code>@param</code> statement specifying any <a href="ref/@ref">Trainable parameters</a>, e.g.:</li></ul><pre><code class="language-julia">@param theta::Float64</code></pre><ul><li>An assignment, with a symbol or tuple of symbols on the left-hand side, and a Julia expression on the right-hand side, which may include <code>@trace</code> expressions, e.g.:</li></ul><pre><code class="language-julia">mu, sigma = @trace(bernoulli(p), :x) ? (mu1, sigma1) : (mu2, sigma2)</code></pre><ul><li>A top-level <code>@trace</code> expression, e.g.:</li></ul><pre><code class="language-julia">@trace(bernoulli(1-prob_tails), :flip)</code></pre><p>All <code>@trace</code> expressions must use a literal Julia symbol for the first component in the address. Unlike the full built-in modeling-language, the address is not optional.</p><ul><li>A <code>return</code> statement, with a Julia expression on the right-hand side, e.g.:</li></ul><pre><code class="language-julia">return @trace(geometric(prob), :n_flips) + 1</code></pre><p>The functions are also subject to the following restrictions:</p><ul><li><p>Default argument values are not supported.</p></li><li><p>Julia closures are not allowed.</p></li><li><p>List comprehensions with internal <code>@trace</code> calls are not allowed.</p></li><li><p>Splatting within <code>@trace</code> calls is not supported</p></li><li><p>Generative functions that are passed in as arguments cannot be traced.</p></li><li><p>For composite addresses (e.g. <code>:a =&gt; 2 =&gt; :c</code>) the first component of the address must be a literal symbol, and there may only be one statement in the function body that uses this symbol for the first component of its address.</p></li><li><p>Julia control flow constructs (e.g. <code>if</code>, <code>for</code>, <code>while</code>) cannot be used as top-level statements in the function body. Control flow should be implemented inside either Julia functions that are called, or other generative functions.</p></li></ul><p>Certain loop constructs can be implemented using <a href="../combinators/#Generative-Function-Combinators-1">Generative Function Combinators</a> instead. For example, the following loop:</p><pre><code class="language-julia">for (i, prob) in enumerate(probs)
    @trace(foo(prob), :foo =&gt; i)
end</code></pre><p>can instead be implemented as:</p><pre><code class="language-julia">@trace(Map(foo)(probs), :foo)</code></pre><h3><a class="nav-anchor" id="Loading-generated-functions-1" href="#Loading-generated-functions-1">Loading generated functions</a></h3><p>Before a function with a static annotation can be used, the <a href="#Gen.@load_generated_functions"><code>@load_generated_functions</code></a> macro must be called:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.@load_generated_functions" href="#Gen.@load_generated_functions"><code>Gen.@load_generated_functions</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@load_generated_functions</code></pre><p>Permit use of generative functions written in the static modeling language up to this point. Functions are loaded into the calling module.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/b433efef7cd0b7c65086a7c2b62d07ee7eacdb77/src/Gen.jl#L19-L24">source</a></section><p>Typically, one call to this function, at the top level of a script, separates the definition of generative functions from the execution of inference code, e.g.:</p><pre><code class="language-julia">using Gen: @load_generated_functions

# define generative functions and inference code
..

# allow static generative functions defined above to be used
@load_generated_functions()

# run inference code
..</code></pre><p>When static generative functions are defined in a Julia module, <a href="#Gen.@load_generated_functions"><code>@load_generated_functions</code></a> should be called after all static functions are defined:</p><pre><code class="language-julia">module MyModule
using Gen
# Include code that defines static generative functions
include(&quot;my_static_gen_functions.jl&quot;)
# Load generated functions defined in this module
@load_generated_functions()
end</code></pre><p>Any script that imports or uses <code>MyModule</code> will then no longer need to call <code>@load_generated_functions</code> in order to use the static generative functions defined in that module:</p><pre><code class="language-julia">using Gen
using MyModule: my_static_gen_fn
trace = simulate(my_static_gen_fn, ())</code></pre><h3><a class="nav-anchor" id="Performance-tips-1" href="#Performance-tips-1">Performance tips</a></h3><p>For better performance when the arguments are simple data types like <code>Float64</code>, annotate the arguments with the concrete type. This permits a more optimized trace data structure to be generated for the generative function.</p><h3><a class="nav-anchor" id="Caching-Julia-values-1" href="#Caching-Julia-values-1">Caching Julia values</a></h3><p>By default, the values of Julia computations (all calls that are not random choices or calls to generative functions) are cached as part of the trace, so that <a href="../gfi/#Updating-traces-1">Updating traces</a> can avoid unecessary re-execution of Julia code. However, this cache may grow the memory footprint of a trace. To disable caching of Julia values, use the function annotation <code>nojuliacache</code> (this annotation is ignored unless the <code>static</code> function annotation is also used).</p><footer><hr/><a class="previous" href="../distributions/"><span class="direction">Previous</span><span class="title">Probability Distributions</span></a><a class="next" href="../combinators/"><span class="direction">Next</span><span class="title">Generative Function Combinators</span></a></footer></article></body></html>
