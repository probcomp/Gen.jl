<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in Modeling Language · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><a class="toctext" href="../../guide/">Guide</a></li><li><span class="toctext">Reference</span><ul><li class="current"><a class="toctext" href>Built-in Modeling Language</a><ul class="internal"><li><a class="toctext" href="#Annotations-1">Annotations</a></li><li><a class="toctext" href="#Making-random-choices-1">Making random choices</a></li><li><a class="toctext" href="#Calling-generative-functions-1">Calling generative functions</a></li><li><a class="toctext" href="#Composite-addresses-1">Composite addresses</a></li><li><a class="toctext" href="#Return-value-1">Return value</a></li><li><a class="toctext" href="#Static-parameters-1">Static parameters</a></li><li><a class="toctext" href="#Differentiable-programming-1">Differentiable programming</a></li><li><a class="toctext" href="#Update-code-blocks-1">Update code blocks</a></li><li><a class="toctext" href="#Static-DSL-1">Static DSL</a></li></ul></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li><li><a class="toctext" href="../gfi/">Generative Function Interface</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Built-in Modeling Language</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/modeling.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Built-in Modeling Language</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Built-in-Modeling-Language-1" href="#Built-in-Modeling-Language-1">Built-in Modeling Language</a></h1><p>Gen provides a built-in embedded modeling language for defining generative functions. The language uses a syntax that extends Julia&#39;s syntax for defining regular Julia functions.</p><p>Generative functions in the modeling language are identified using the <code>@gen</code> keyword in front of a Julia function definition. Here is an example <code>@gen</code> function that samples two random choices:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    z1 = @addr(bernoulli(prob), :a)
    z2 = @addr(bernoulli(prob), :b)
    return z1 || z2
end</code></pre><p>After running this code, <code>foo</code> is a Julia value of type <code>DynamicDSLFunction</code>, which is a subtype of <code>GenerativeFunction</code>. We can call the resulting generative function:</p><pre><code class="language-julia">retval::Bool = foo(0.5)</code></pre><p>We can also trace its execution:</p><pre><code class="language-julia">(trace, _) = initialize(foo, (0.5,))</code></pre><p>See <a href="ref/@ref">Generative Function Interface</a> for the full set of operations supported by a generative function. Note that the built-in modeling language described in this section is only one of many ways of defining a generative function – generative functions can also be constructed using other embedded languages, or by directly implementing the methods of the generative function interface. However, the built-in modeling language is intended to being flexible enough cover a wide range of use cases and to use when learning the Gen programming model.</p><p>In the remainder of this section, we refer to generative functions defined using the embedded modeling language as <code>@gen</code> functions.</p><h2><a class="nav-anchor" id="Annotations-1" href="#Annotations-1">Annotations</a></h2><p>Annotations are a syntactic construct in the modeling language that allows users to provide additional information about how <code>@gen</code> functions should be interpreted. There are two types of annotations – <em>argument annotations</em> and <em>function annotations</em>.</p><p><strong>Argument annotations.</strong> In addition to type declarations on arguments like regular Julia functions, <code>@gen</code> functions also support additional annotations on arguments. Each argument can have the following different syntactic forms:</p><ul><li><p><code>y</code>: No type declaration; no annotations.</p></li><li><p><code>y::Float64</code>: Type declaration; but no annotations.</p></li><li><p><code>(grad)(y)</code>: No type declaration provided;, annotated with <code>grad</code>.</p></li><li><p><code>(grad)(y::Float64)</code>: Type declaration provided; and annotated with <code>grad</code>.</p></li></ul><p>Currently, the possible argument annotations are:</p><ul><li><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</li></ul><p><strong>Function annotations.</strong> The <code>@gen</code> function itself can also be optionally associated with zero or more annotations, which are separate from the per-argument annotations. Function-level annotations use the following different syntactic forms:</p><ul><li><p><code>@gen function foo(&lt;args&gt;) &lt;body&gt; end</code>: No function annotations.</p></li><li><p><code>@gen function (grad) foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has the <code>grad</code> annotation. </p></li><li><p><code>@gen function (grad,static) foo(&lt;args&gt;) &lt;body&gt; end</code>: The function has both the <code>grad</code> and <code>static</code> annotations.</p></li></ul><p>Currently the possible function annotations are:</p><ul><li><p><code>grad</code> (see <a href="ref/@ref">Differentiable programming</a>).</p></li><li><p><code>static</code> (see <a href="#Static-DSL-1">Static DSL</a>).</p></li></ul><h2><a class="nav-anchor" id="Making-random-choices-1" href="#Making-random-choices-1">Making random choices</a></h2><p>Random choices are made by applying a probability distribution to some arguments:</p><pre><code class="language-julia">val::Bool = bernoulli(0.5)</code></pre><p>See <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a> for the set of built-in probability distributions.</p><p>In the body of a <code>@gen</code> function, wrapping the right-hand side of the expression with an <code>@addr</code> expression associates the random choice with an <em>address</em>, and evaluates to the value of the random choice. The syntax is:</p><pre><code class="language-julia">@addr(&lt;distribution&gt;(&lt;args&gt;), &lt;addr&gt;)</code></pre><p>Addresses can be any Julia value. Here, we give the Julia symbol address <code>:z</code> to a Bernoulli random choice.</p><pre><code class="language-julia">val::Bool = @addr(bernoulli(0.5), :z)</code></pre><p>Not all random choices need to be given addresses. An address is required if the random choice will be observed, or will be referenced by a custom inference algorithm (e.g. if it will be proposed to by a custom proposal distribution).</p><p>It is recommended to ensure that the support of a random choice at a given address (the set of values with nonzero probability or probability density) is constant across all possible executions of the <code>@gen</code> function. This discipline will simplify reasoning about the probabilistic behavior of the function, and will help avoid difficult-to-debug NaNs or Infs from appearing. If the support of a random choice needs to change, consider using a different address for each distinct support.</p><h2><a class="nav-anchor" id="Calling-generative-functions-1" href="#Calling-generative-functions-1">Calling generative functions</a></h2><p><code>@gen</code> functions can invoke other generative functions in three ways:</p><p><strong>Untraced call</strong>: If <code>foo</code> is a generative function, we can invoke <code>foo</code> from within the body of a <code>@gen</code> function using regular call syntax. The random choices made within the call are not given addresses in our trace, and are therefore <em>non-addressable</em> random choices (see <a href="ref/@ref">Generative Function Interface</a> for details on non-addressable random choices).</p><pre><code class="language-julia">val = foo(0.5)</code></pre><p><strong>Traced call with shared address namespace</strong>: We can include the addressable random choices made by <code>foo</code> in the caller&#39;s trace using <code>@splice</code>:</p><pre><code class="language-julia">val = @splice(foo(0.5))</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace. The caller must guarantee that there are no address collisions.</p><p><strong>Traced call with a nested address namespace</strong>: We can include the addressable random choices made by <code>foo</code> in the caller&#39;s trace, under a namespace, using <code>@addr</code>:</p><pre><code class="language-julia">val = @addr(foo(0.5), :x)</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace, under the namespace <code>:x</code>. For example, if <code>foo</code> makes random choices at addresses <code>:a</code> and <code>:b</code>, these choices will have addresses <code>:x =&gt; :a</code> and <code>:x =&gt; :b</code> in the caller&#39;s trace.</p><h2><a class="nav-anchor" id="Composite-addresses-1" href="#Composite-addresses-1">Composite addresses</a></h2><p>In Julia, <code>Pair</code> values can be constructed using the <code>=&gt;</code> operator. For example, <code>:a =&gt; :b</code> is equivalent to <code>Pair(:a, :b)</code> and <code>:a =&gt; :b =&gt; :c</code> is equivalent to <code>Pair(:a, Pair(:b, :c))</code>. A <code>Pair</code> value (e.g. <code>:a =&gt; :b =&gt; :c</code>) can be passed as the address field in an <code>@addr</code> expression, provided that there is not also a random choice or generative function called with <code>@addr</code> at any prefix of the address.</p><p>Consider the following examples.</p><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(normal(0, 1), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(normal(0, 1), :a)</code></pre><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a)
@addr(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b)
@addr(normal(0, 1), :a =&gt; :c)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b)
@addr(foo(0.5), :a =&gt; :c)</code></pre><h2><a class="nav-anchor" id="Return-value-1" href="#Return-value-1">Return value</a></h2><p>Like regular Julia functions, <code>@gen</code> functions return either the expression used in a <code>return</code> keyword, or by evaluating the last expression in the function body. Note that the return value of a <code>@gen</code> function is different from a trace of <code>@gen</code> function, which contains the return value associated with an execution as well as the assignment to each random choice made during the execution. See <a href="ref/@ref">Generative Function Interface</a> for more information about traces.</p><h2><a class="nav-anchor" id="Static-parameters-1" href="#Static-parameters-1">Static parameters</a></h2><p>A <code>@gen</code> function may begin with an optional block of <em>static paramter declarations</em>. The block consists of a sequence of statements, beginning with <code>@param</code>, that declare the name and Julia type for each static parameter. The function below has a single static parameter <code>theta</code> with type <code>Float64</code>:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    @param theta::Float64
    z1 = @addr(bernoulli(prob), :a)
    z2 = @addr(bernoulli(theta), :b)
    return z1 || z2
end</code></pre><p>Static parameters obey the same scoping rules as Julia local variables defined at the beginning of the function body. The value of a static parameter is undefined until it is initialized using the following method:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.init_param!" href="#Gen.init_param!"><code>Gen.init_param!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">init_param!(gen_fn, name::Symbol, value)</code></pre><p>Initialize the the value of a named static parameter of a generative function.</p><p>Also initializes the gradient accumulator for that parameter to <code>zero(value)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/957cefef21916a3700456a97b6828a6cef16c636/src/dynamic/dynamic.jl#L98-L104">source</a></section><p>For example:</p><pre><code class="language-julia">init_param!(foo, :theta, 0.6)</code></pre><p>Static parameters are designed to be trained using gradient-based methods. This is discussed in <a href="ref/@ref">Differentiable programming</a>.</p><h2><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h2><p><code>@gen</code> functions can use automatic differentiation to compute gradients with respect to (i) all or a subset of the arguments to the function, and (ii) the values of certain random choices, (iii) the static parameters of the <code>@gen</code> function. We first discuss the semantics of these gradient computations, and then discuss what how to write and use Julia code in the body of a <code>@gen</code> function so that it can be automatically differentiated by the gradient computation.</p><h3><a class="nav-anchor" id="Supported-gradient-computations-1" href="#Supported-gradient-computations-1">Supported gradient computations</a></h3><p><strong>Gradients with respect to arguments.</strong> A <code>@gen</code> function may have a fixed set of its arguments annotated with <code>grad</code>, which indicates that gradients with respect to that argument should be supported. For example, in the function below, we indicate that we want to support differentiation with respect to the <code>y</code> argument, but that we do not want to support differentiation with respect to the <code>x</code> argument.</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        @addr(normal(y, 1), :z)
    else
        @addr(normal(y, 10), :z)
    end
end</code></pre><p>By default, the function being differentiated is the log probability (density) of the random choices. For the function <code>foo</code> above, when <code>x &gt; 5</code>, the gradient with respect to <code>y</code> is the gradient of the log probability density of a normal distribution with standard deviation 1, with respect to its mean, evaluated at mean <code>y</code>. When <code>x &lt;= 5</code>, we instead differentiate the log density of a normal distribution with standard deviation 10, relative to its mean.</p><p><strong>Gradients with respect to values of random choices.</strong> The author of a <code>@gen</code> function also identifies a set of addresses of random choices with respect to which they wish to support gradients of the log probability (density). Gradients of the log probability (density) with respect to the values of random choices are used in gradient-based numerical optimization of random choices, as well as certain MCMC updates that require gradient information.</p><p><strong>Gradients with respect to static parameters.</strong> The gradient of the log probability (density) with respect to the static parameters can also be computed using automatic differentiation. Currently, the log probability (density) must be a differentiable function of all static parameters.</p><p><strong>Gradients of a function of the return value.</strong> Differentiable programming in Gen composes across function calls. If the return value of the <code>@gen</code> function is conditionally dependent on source elements including (i) any arguments annotated with <code>grad</code> or (ii) any random choices for which gradients are supported, or (ii) any static parameters, then the gradient computation requires a gradient of the an external function with respect to the return value in order to the compute the correct gradients. Thus, the function being differentiated always includes a term representing the log probability (density) of all random choices made by the function, but can be extended with a term that depends on the return value of the function. The author of a <code>@gen</code> function can indicate that the return value depends on the source elements (causing the gradient with respect to the return value is required for all gradient computations) by adding the <code>grad</code> annotation to the <code>@gen</code> function itself. For example, in the function below, the return value is conditionally dependent (and actually identical to) on the random value at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(x, (grad)(y))
    if x &gt; 5
        @addr(normal(y, 1), :z)
    else
        @addr(normal(y, 10), :z)
    end
end</code></pre><p>If the author of <code>foo</code> wished to support the computation of gradients with respect to the value of <code>:z</code>, they would need to add the <code>grad</code> annotation to <code>foo</code> using the following syntax:</p><pre><code class="language-julia">@gen (grad) function foo(x, (grad)(y))
    if x &gt; 5
        @addr(normal(y, 1), :z)
    else
        @addr(normal(y, 10), :z)
    end
end</code></pre><h3><a class="nav-anchor" id="Writing-differentiable-code-1" href="#Writing-differentiable-code-1">Writing differentiable code</a></h3><p>In order to compute the gradients described above, the code in the body of the <code>@gen</code> function needs to be differentiable. Code in the body of a <code>@gen</code> function consists of:</p><ul><li><p>Julia code</p></li><li><p>Making random choices</p></li><li><p>Calling generative functions</p></li></ul><p>We now discuss how to ensure that code of each of these forms is differentiable. Note that the procedures for differentiation of code described below are only performed during certain operations on <code>@gen</code> functions (<code>backprop_trace</code> and <code>backprop_params</code>).</p><p><strong>Julia code.</strong> Julia code used within a body of a <code>@gen</code> function is made differentiable using the <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> package, which implements  reverse-mode automatic differentiation. Specifically, values whose gradient is required (either values of arguments, random choices, or static parameters) are &#39;tracked&#39; by boxing them into special values and storing the tracked value on a &#39;tape&#39;. For example a <code>Float64</code> value is boxed into a <code>ReverseDiff.TrackedReal</code> value. Methods (including e.g. arithmetic operators) are defined that operate on these tracked values and produce other tracked values as a result. As the computation proceeds all the values are placed onto the tape, with back-references to the parent operation and operands. Arithmetic operators, array and linear algebra functions, and common special numerical functions, as well as broadcasting, are automatically supported. See <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff</a> for more details.</p><p><strong>Making random choices.</strong> When making a random choice, each argument is either a tracked value or not. If the argument is a tracked value, then the probability distribution must support differentiation of the log probability (density) with respect to that argument. Otherwise, an error is thrown. The <code>has_argument_grads</code> function indicates which arguments support differentiation for a given distribution (see <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a>). If the gradient is required for the <em>value</em> of a random choice, the distribution must support differentiation of the log probability (density) with respect to the value. This is indicated by the <code>has_output_grad</code> function.</p><p><strong>Calling generative functions.</strong> Like distributions, generative functions indicate which of their arguments support differentiation, using the <code>has_argument_grads</code> function. It is an error if a tracked value is passed as an argument of a generative function, when differentiation is not supported by the generative function for that argument. If a generative function <code>gen_fn</code> has <code>accepts_output_grad(gen_fn) = true</code>, then the return value of the generative function call will be tracked and will propagate further through the caller <code>@gen</code> function&#39;s computation.</p><h2><a class="nav-anchor" id="Update-code-blocks-1" href="#Update-code-blocks-1">Update code blocks</a></h2><h2><a class="nav-anchor" id="Static-DSL-1" href="#Static-DSL-1">Static DSL</a></h2><p>The <em>Static DSL</em> supports a subset of the built-in modeling language. A static DSL function is identified by adding the <code>static</code> annotation to the function. For example:</p><pre><code class="language-julia">@gen (static) function foo(prob::Float64)
    z1 = @addr(bernoulli(prob), :a)
    z2 = @addr(bernoulli(prob), :b)
    z3 = z1 || z2
    return z3
end</code></pre><p>After running this code, <code>foo</code> is a Julia value whose type is a subtype of <code>StaticIRGenerativeFunction</code>, which is a subtype of <code>GenerativeFunction</code>.</p><p>The static DSL permits a subset of the syntax of the built-in modeling language. In particular, each statement must be one of the following forms:</p><ul><li><p><code>&lt;symbol&gt; = &lt;julia-expr&gt;</code></p></li><li><p><code>&lt;symbol&gt; = @addr(&lt;dist|gen-fn&gt;(..),&lt;symbol&gt; [ =&gt; ..])</code></p></li><li><p><code>@addr(&lt;dist|gen-fn&gt;(..),&lt;symbol&gt; [ =&gt; ..])</code></p></li><li><p><code>return &lt;symbol&gt;</code></p></li></ul><p>Currently, static parameters are not supported in static DSL functions.</p><p>Note that the <code>@addr</code> keyword may only appear in at the top-level of the right-hand-side expresssion. Also, addresses used with the <code>@addr</code> keyword must be a literal Julia symbol (e.g. <code>:a</code>). If multi-part addresses are used, the first component in the multi-part address must be a literal Julia symbol (e.g. <code>:a =&gt; i</code> is valid).</p><p>Also, symbols used on the left-hand-side of assignment statements must be unique (this is called &#39;static single assignment&#39; (SSA) form) (this is called &#39;static single-assignment&#39; (SSA) form).</p><p><strong>Loading generated functions.</strong> Before a static DSL function can be invoked at runtime, <code>Gen.load_generated_functions()</code> method must be called. Typically, this call immediately preceeds the execution of the inference algorithm.</p><p><strong>Performance tips.</strong> For better performance, annotate the left-hand side of random choices with the type. This permits a more optimized trace data structure to be generated for the generative function. For example:</p><pre><code class="language-julia">@gen (static) function foo(prob::Float64)
    z1::Bool = @addr(bernoulli(prob), :a)
    z2::Bool = @addr(bernoulli(prob), :b)
    z3 = z1 || z2
    return z3
end</code></pre><footer><hr/><a class="previous" href="../../guide/"><span class="direction">Previous</span><span class="title">Guide</span></a><a class="next" href="../combinators/"><span class="direction">Next</span><span class="title">Generative Function Combinators</span></a></footer></article></body></html>
