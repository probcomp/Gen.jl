<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Gen · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Modeling Languages and APIs</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../trace_translators/">Trace Translators</a></li><li class="current"><a class="toctext" href>Extending Gen</a><ul class="internal"><li><a class="toctext" href="#Custom-gradients-1">Custom gradients</a></li><li><a class="toctext" href="#Custom-incremental-computation-1">Custom incremental computation</a></li><li><a class="toctext" href="#custom_distributions-1">Custom distributions</a></li><li><a class="toctext" href="#Custom-generative-functions-1">Custom generative functions</a></li><li><a class="toctext" href="#Custom-modeling-languages-1">Custom modeling languages</a></li></ul></li></ul></li><li><span class="toctext">Standard Inference Library</span><ul><li><a class="toctext" href="../importance/">Importance Sampling</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../pf/">Particle Filtering</a></li><li><a class="toctext" href="../vi/">Variational Inference</a></li><li><a class="toctext" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modeling Languages and APIs</li><li><a href>Extending Gen</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/extending.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending Gen</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Extending-Gen-1" href="#Extending-Gen-1">Extending Gen</a></h1><p>Gen is designed for extensibility. To implement behaviors that are not directly supported by the existing modeling languages, users can implement `black-box&#39; generative functions directly, without using built-in modeling language. These generative functions can then be invoked by generative functions defined using the built-in modeling language. This includes several special cases:</p><ul><li><p>Extending Gen with custom gradient computations</p></li><li><p>Extending Gen with custom incremental computation of return values</p></li><li><p>Extending Gen with new modeling languages.</p></li></ul><h2><a class="nav-anchor" id="Custom-gradients-1" href="#Custom-gradients-1">Custom gradients</a></h2><p>To add a custom gradient for a differentiable deterministic computation, define a concrete subtype of <a href="#Gen.CustomGradientGF"><code>CustomGradientGF</code></a> with the following methods:</p><ul><li><p><a href="#Gen.apply"><code>apply</code></a></p></li><li><p><a href="#Gen.gradient"><code>gradient</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>For example:</p><pre><code class="language-julia">struct MyPlus &lt;: CustomGradientGF{Float64} end

Gen.apply(::MyPlus, args) = args[1] + args[2]
Gen.gradient(::MyPlus, args, retval, retgrad) = (retgrad, retgrad)
Gen.has_argument_grads(::MyPlus) = (true, true)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.CustomGradientGF" href="#Gen.CustomGradientGF"><code>Gen.CustomGradientGF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CustomGradientGF{T}</code></pre><p>Abstract type for a generative function with a custom gradient computation, and default behaviors for all other generative function interface methods.</p><p><code>T</code> is the type of the return value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L138-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.apply" href="#Gen.apply"><code>Gen.apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">retval = apply(gen_fn::CustomGradientGF, args)</code></pre><p>Apply the function to the arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L151-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.gradient" href="#Gen.gradient"><code>Gen.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = gradient(gen_fn::CustomDetermGF, args, retval, retgrad)</code></pre><p>Return the gradient tuple with respect to the arguments, where <code>nothing</code> is for argument(s) whose gradient is not available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L165-L169">source</a></section><h2><a class="nav-anchor" id="Custom-incremental-computation-1" href="#Custom-incremental-computation-1">Custom incremental computation</a></h2><p>Iterative inference techniques like Markov chain Monte Carlo involve repeatedly updating the execution traces of generative models. In some cases, the output of a deterministic computation within the model can be incrementally computed during each of these updates, instead of being computed from scratch.</p><p>To add a custom incremental computation for a deterministic computation, define a concrete subtype of <a href="#Gen.CustomUpdateGF"><code>CustomUpdateGF</code></a> with the following methods:</p><ul><li><p><a href="#Gen.apply_with_state"><code>apply_with_state</code></a></p></li><li><p><a href="#Gen.update_with_state"><code>update_with_state</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>The second type parameter of <code>CustomUpdateGF</code> is the type of the state that may be used internally to facilitate incremental computation within <code>update_with_state</code>.</p><p>For example, we can implement a function for computing the sum of a vector that efficiently computes the new sum when a small fraction of the vector elements change:</p><pre><code class="language-julia">struct MyState
    prev_arr::Vector{Float64}
    sum::Float64
end

struct MySum &lt;: CustomUpdateGF{Float64,MyState} end

function Gen.apply_with_state(::MySum, args)
    arr = args[1]
    s = sum(arr)
    state = MyState(arr, s)
    (s, state)
end

function Gen.update_with_state(::MySum, state, args, argdiffs::Tuple{VectorDiff})
    arr = args[1]
    prev_sum = state.sum
    retval = prev_sum
    for i in keys(argdiffs[1].updated)
        retval += (arr[i] - state.prev_arr[i])
    end
    prev_length = length(state.prev_arr)
    new_length = length(arr)
    for i=prev_length+1:new_length
        retval += arr[i]
    end
    for i=new_length+1:prev_length
        retval -= arr[i]
    end
    state = MyState(arr, retval)
    (state, retval, UnknownChange())
end

Gen.num_args(::MySum) = 1</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.CustomUpdateGF" href="#Gen.CustomUpdateGF"><code>Gen.CustomUpdateGF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CustomUpdateGF{T,S}</code></pre><p>Abstract type for a generative function with a custom update computation, and default behaviors for all other generative function interface methods.</p><p><code>T</code> is the type of the return value and <code>S</code> is the type of state used internally for incremental computation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L185-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.apply_with_state" href="#Gen.apply_with_state"><code>Gen.apply_with_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">retval, state = apply_with_state(gen_fn::CustomDetermGF, args)</code></pre><p>Execute the generative function and return the return value and the state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L40-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.update_with_state" href="#Gen.update_with_state"><code>Gen.update_with_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">state, retval, retdiff = update_with_state(gen_fn::CustomDetermGF, state, args, argdiffs)</code></pre><p>Update the arguments to the generative function and return new return value and state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/custom_determ.jl#L47-L51">source</a></section><h2><a class="nav-anchor" id="custom_distributions-1" href="#custom_distributions-1">Custom distributions</a></h2><p>Users can extend Gen with new probability distributions, which can then be used to make random choices within generative functions. Simple transformations of existing distributions can be created using the <a href="../distributions/#dist_dsl-1"><code>@dist</code> DSL</a>. For arbitrary distributions, including distributions that cannot be expressed in the <code>@dist</code> DSL, users can define a custom distribution by implementing Gen&#39;s Distribution interface directly, as defined below.</p><p>Probability distributions are singleton types whose supertype is <code>Distribution{T}</code>, where <code>T</code> indicates the data type of the random sample.</p><pre><code class="language-julia">abstract type Distribution{T} end</code></pre><p>A new Distribution type must implement the following methods:</p><ul><li><p><a href="#Gen.random"><code>random</code></a></p></li><li><p><a href="#Gen.logpdf"><code>logpdf</code></a></p></li><li><p><a href="#Gen.has_output_grad"><code>has_output_grad</code></a></p></li><li><p><a href="#Gen.logpdf_grad"><code>logpdf_grad</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li></ul><p>By convention, distributions have a global constant lower-case name for the singleton value. For example:</p><pre><code class="language-julia">struct Bernoulli &lt;: Distribution{Bool} end
const bernoulli = Bernoulli()</code></pre><p>Distribution values should also be callable, which is a syntactic sugar with the same behavior of calling <code>random</code>:</p><pre><code class="language-julia">bernoulli(0.5) # identical to random(bernoulli, 0.5) and random(Bernoulli(), 0.5)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.random" href="#Gen.random"><code>Gen.random</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">val::T = random(dist::Distribution{T}, args...)</code></pre><p>Sample a random choice from the given distribution with the given arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/modeling_library.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.logpdf" href="#Gen.logpdf"><code>Gen.logpdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lpdf = logpdf(dist::Distribution{T}, value::T, args...)</code></pre><p>Evaluate the log probability (density) of the value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/modeling_library.jl#L17-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_output_grad" href="#Gen.has_output_grad"><code>Gen.has_output_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has::Bool = has_output_grad(dist::Distribution)</code></pre><p>Return true of the gradient if the distribution computes the gradient of the logpdf with respect to the value of the random choice.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/modeling_library.jl#L24-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.logpdf_grad" href="#Gen.logpdf_grad"><code>Gen.logpdf_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">grads::Tuple = logpdf_grad(dist::Distribution{T}, value::T, args...)</code></pre><p>Compute the gradient of the logpdf with respect to the value, and each of the arguments.</p><p>If <code>has_output_grad</code> returns false, then the first element of the returned tuple is <code>nothing</code>. Otherwise, the first element of the tuple is the gradient with respect to the value. If the return value of <code>has_argument_grads</code> has a false value for at position <code>i</code>, then the <code>i+1</code>th element of the returned tuple has value <code>nothing</code>. Otherwise, this element contains the gradient with respect to the <code>i</code>th argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/dec8c539f079bde0df9875e832cbb11ceb9440d7/src/modeling_library/modeling_library.jl#L31-L40">source</a></section><h2><a class="nav-anchor" id="Custom-generative-functions-1" href="#Custom-generative-functions-1">Custom generative functions</a></h2><p>We recommend the following steps for implementing a new type of generative function, and also looking at the implementation for the <a href="../modeling/#Gen.DynamicDSLFunction"><code>DynamicDSLFunction</code></a> type as an example.</p><h5><a class="nav-anchor" id="Define-a-trace-data-type-1" href="#Define-a-trace-data-type-1">Define a trace data type</a></h5><pre><code class="language-julia">struct MyTraceType &lt;: Trace
    ..
end</code></pre><h5><a class="nav-anchor" id="Decide-the-return-type-for-the-generative-function-1" href="#Decide-the-return-type-for-the-generative-function-1">Decide the return type for the generative function</a></h5><p>Suppose our return type is <code>Vector{Float64}</code>.</p><h5><a class="nav-anchor" id="Define-a-data-type-for-your-generative-function-1" href="#Define-a-data-type-for-your-generative-function-1">Define a data type for your generative function</a></h5><p>This should be a subtype of <a href="../gfi/#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>, with the appropriate type parameters.</p><pre><code class="language-julia">struct MyGenerativeFunction &lt;: GenerativeFunction{Vector{Float64},MyTraceType}
..
end</code></pre><p>Note that your generative function may not need to have any fields. You can create a constructor for it, e.g.:</p><pre><code class="language-none">function MyGenerativeFunction(...)
..
end</code></pre><h5><a class="nav-anchor" id="Decide-what-the-arguments-to-a-generative-function-should-be-1" href="#Decide-what-the-arguments-to-a-generative-function-should-be-1">Decide what the arguments to a generative function should be</a></h5><p>For example, our generative functions might take two arguments, <code>a</code> (of type <code>Int</code>) and <code>b</code> (of type <code>Float64</code>). Then, the argument tuple passed to e.g. <a href="../gfi/#Gen.generate"><code>generate</code></a> will have two elements.</p><p>NOTE: Be careful to distinguish between arguments to the generative function itself, and arguments to the constructor of the generative function. For example, if you have a generative function type that is parametrized by, for example, modeling DSL code, this DSL code would be a parameter of the generative function constructor.</p><h5><a class="nav-anchor" id="Decide-what-the-traced-random-choices-(if-any)-will-be-1" href="#Decide-what-the-traced-random-choices-(if-any)-will-be-1">Decide what the traced random choices (if any) will be</a></h5><p>Remember that each random choice is assigned a unique address in (possibly) hierarchical address space. You are free to design this address space as you wish, although you should document it for users of your generative function type.</p><h5><a class="nav-anchor" id="Implement-methods-of-the-Generative-Function-Interface-1" href="#Implement-methods-of-the-Generative-Function-Interface-1">Implement methods of the Generative Function Interface</a></h5><p>At minimum, you need to implement the following methods:</p><ul><li><p><a href="../gfi/#Gen.simulate"><code>simulate</code></a></p></li><li><p><a href="../gfi/#Gen.has_argument_grads"><code>has_argument_grads</code></a></p></li><li><p><a href="../gfi/#Gen.accepts_output_grad"><code>accepts_output_grad</code></a></p></li><li><p><a href="../gfi/#Gen.get_args"><code>get_args</code></a></p></li><li><p><a href="../gfi/#Gen.get_retval"><code>get_retval</code></a></p></li><li><p><a href="../gfi/#Gen.get_choices"><code>get_choices</code></a></p></li><li><p><a href="../gfi/#Gen.get_score"><code>get_score</code></a></p></li><li><p><a href="../gfi/#Gen.get_gen_fn"><code>get_gen_fn</code></a></p></li><li><p><a href="../gfi/#Gen.project"><code>project</code></a></p></li></ul><p>If you want to use the generative function within models, you should implement:</p><ul><li><a href="../gfi/#Gen.generate"><code>generate</code></a></li></ul><p>If you want to use MCMC on models that call your generative function, then implement:</p><ul><li><p><a href="../gfi/#Gen.update"><code>update</code></a></p></li><li><p><a href="../gfi/#Gen.regenerate"><code>regenerate</code></a></p></li></ul><p>If you want to use gradient-based inference techniques on models that call your generative function, then implement:</p><ul><li><p><a href="../gfi/#Gen.choice_gradients"><code>choice_gradients</code></a></p></li><li><p><a href="../gfi/#Gen.update"><code>update</code></a></p></li></ul><p>If your generative function has trainable parameters, then implement:</p><ul><li><a href="../gfi/#Gen.accumulate_param_gradients!"><code>accumulate_param_gradients!</code></a></li></ul><h2><a class="nav-anchor" id="Custom-modeling-languages-1" href="#Custom-modeling-languages-1">Custom modeling languages</a></h2><p>Gen can be extended with new modeling languages by implementing new generative function types, and constructors for these types that take models as input. This typically requires implementing the entire generative function interface, and is advanced usage of Gen.</p><footer><hr/><a class="previous" href="../trace_translators/"><span class="direction">Previous</span><span class="title">Trace Translators</span></a><a class="next" href="../importance/"><span class="direction">Next</span><span class="title">Importance Sampling</span></a></footer></article></body></html>
