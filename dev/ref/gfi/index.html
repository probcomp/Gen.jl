<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Function Interface · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><a class="toctext" href="../../guide/">Guide</a></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../modeling/">Modeling Languages</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li><li class="current"><a class="toctext" href>Generative Function Interface</a><ul class="internal"></ul></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Generative Function Interface</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/gfi.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Function Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Function-Interface-1" href="#Generative-Function-Interface-1">Generative Function Interface</a></h1><p>A <em>trace</em> is a record of an execution of a generative function. There is no abstract type representing all traces. Generative functions implement the <em>generative function interface</em>, which is a set of methods that involve the execution traces and probabilistic behavior of generative functions. In the mathematical description of the interface methods, we denote arguments to a function by <span>$x$</span>, complete assignments of values to addresses of random choices (containing all the random choices made during some execution) by <span>$t$</span> and partial assignments by either <span>$u$</span> or <span>$v$</span>. We denote a trace of a generative function by the tuple <span>$(x, t)$</span>. We say that two assignments <span>$u$</span> and <span>$t$</span> <em>agree</em> when they assign addresses that appear in both assignments to the same values (they can different or even disjoint sets of addresses and still agree). A generative function is associated with a family of probability distributions <span>$P(t; x)$</span> on assignments <span>$t$</span>, parameterized by arguments <span>$x$</span>, and a second family of distributions <span>$Q(t; u, x)$</span> on assignments <span>$t$</span> parameterized by partial assignment <span>$u$</span> and arguments <span>$x$</span>. <span>$Q$</span> is called the <em>internal proposal family</em> of the generative function, and satisfies that if <span>$u$</span> and <span>$t$</span> agree then <span>$P(t; x) &gt; 0$</span> if and only if <span>$Q(t; x, u) &gt; 0$</span>, and that <span>$Q(t; x, u) &gt; 0$</span> implies that <span>$u$</span> and <span>$t$</span> agree. See the <a href="http://hdl.handle.net/1721.1/119255">Gen technical report</a> for additional details.</p><p>Generative functions may also use <em>non-addressable random choices</em>, denoted <span>$r$</span>. Unlike regular (addressable) random choices, non-addressable random choices do not have addresses, and the value of non-addressable random choices is not exposed through the generative function interface. However, the state of non-addressable random choices is maintained in the trace. A trace that contains non-addressable random choices is denoted <span>$(x, t, r)$</span>. Non-addressable random choices manifest to the user of the interface as stochasticity in weights returned by generative function interface methods. The behavior of non-addressable random choices is defined by an additional pair of families of distributions associated with the generative function, denoted <span>$Q(r; x, t)$</span> and <span>$P(r; x, t)$</span>, which are defined for <span>$P(t; x) &gt; 0$</span>, and which satisfy <span>$Q(r; x, t) &gt; 0$</span> if and only if <span>$P(r; x, t) &gt; 0$</span>. For each generative function below, we describe its semantics first in the basic setting where there is no non-addressable random choices, and then in the more general setting that may include non-addressable random choices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize" href="#Gen.initialize"><code>Gen.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = initialize(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                assmt::Assignment)</code></pre><p>Return a trace of a generative function that is consistent with the given assignment.</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>assmt</code>), sample <span>$t \sim Q(\cdot; u, x)$</span> and return the trace <span>$(x, t)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, the trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L70-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p><strong>Basic case</strong></p><p>Given a trace <span>$(x, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L104-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p><strong>Basic case</strong></p><p>Given arguments (<code>args</code>), sample <span>$t&#39; \sim P(\cdot; x)$</span>, and return <span>$t$</span> (<code>assmt</code>) and the weight (<code>weight</code>) <span>$P(t; x)$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim P(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L132-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, assmt::Assignment)</code></pre><p>Return the probability of proposing an assignment</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>assmt</code>) such that <span>$P(t; x) &gt; 0$</span>, return the weight (<code>weight</code>) <span>$P(t; x)$</span>.  It is an error if <span>$P(t; x) = 0$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L155-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.force_update" href="#Gen.force_update"><code>Gen.force_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = force_update(args::Tuple, argdiff, trace,
                                                     assmt::Assignment)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L180-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.fix_update" href="#Gen.fix_update"><code>Gen.fix_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = fix_update(args::Tuple, argdiff, trace,
                                                   assmt::Assignment)</code></pre><p>Update a trace, by changing the arguments and/or providing new values for some existing random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  Let <span>$u + t$</span> denote the merge of <span>$u$</span> and <span>$t$</span> (with <span>$u$</span> taking precedence).  Sample <span>$t&#39; \sim Q(\cdot; u + t, x)$</span>. All addresses in <span>$u$</span> must appear in <span>$t$</span> and in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the values from <span>$t$</span> for addresses in <span>$u$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)} \cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L215-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.free_update" href="#Gen.free_update"><code>Gen.free_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = free_update(args::Tuple, argdiff, trace,
                                           selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span>.  Return the new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L250-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(args::Tuple, argdiff, trace, assmt::Assignment)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, and we also sample <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L287-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_params" href="#Gen.backprop_params"><code>Gen.backprop_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = backprop_params(trace, retgrad)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L317-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_trace" href="#Gen.backprop_trace"><code>Gen.backprop_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = backprop_trace(trace, selection::AddressSet,
                                                          retgrad)</code></pre><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L345-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_assmt" href="#Gen.get_assmt"><code>Gen.get_assmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_assmt(trace)</code></pre><p>Return a value implementing the assignment interface</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p><strong>Basic case</strong></p><p>Return <span>$P(t; x)$</span></p><p><strong>General case</strong></p><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/7800b84e22f349db7a91fc1c6a9882ee26a56d3e/src/gen_fn_interface.jl#L26-L36">source</a></section><footer><hr/><a class="previous" href="../inference/"><span class="direction">Previous</span><span class="title">Inference Library</span></a><a class="next" href="../distributions/"><span class="direction">Next</span><span class="title">Probability Distributions</span></a></footer></article></body></html>
