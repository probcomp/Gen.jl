<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inference Library · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Language and API Reference</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../choice_maps/">Choice Maps</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li class="current"><a class="toctext" href>Inference Library</a><ul class="internal"><li><a class="toctext" href="#Importance-Sampling-1">Importance Sampling</a></li><li><a class="toctext" href="#Markov-Chain-Monte-Carlo-1">Markov Chain Monte Carlo</a></li><li><a class="toctext" href="#Optimization-over-Random-Choices-1">Optimization over Random Choices</a></li><li><a class="toctext" href="#Particle-Filtering-1">Particle Filtering</a></li><li><a class="toctext" href="#Supervised-Training-1">Supervised Training</a></li><li><a class="toctext" href="#Variational-Inference-1">Variational Inference</a></li></ul></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Inference Library</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/inference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Inference Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Inference-Library-1" href="#Inference-Library-1">Inference Library</a></h1><h2><a class="nav-anchor" id="Importance-Sampling-1" href="#Importance-Sampling-1">Importance Sampling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.importance_sampling" href="#Gen.importance_sampling"><code>Gen.importance_sampling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(traces, log_norm_weights, lml_est) = importance_sampling(model::GenerativeFunction,
    model_args::Tuple, observations::ChoiceMap, num_samples::Int)

(traces, log_norm_weights, lml_est) = importance_sampling(model::GenerativeFunction,
    model_args::Tuple, observations::ChoiceMap,
    proposal::GenerativeFunction, proposal_args::Tuple,
    num_samples::Int)</code></pre><p>Run importance sampling, returning a vector of traces with associated log weights.</p><p>The log-weights are normalized. Also return the estimate of the marginal likelihood of the observations (<code>lml_est</code>). The observations are addresses that must be sampled by the model in the given model arguments. The first variant uses the internal proposal distribution of the model. The second variant uses a custom proposal distribution defined by the given generative function. All addresses of random choices sampled by the proposal should also be sampled by the model function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/importance.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.importance_resampling" href="#Gen.importance_resampling"><code>Gen.importance_resampling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace, lml_est) = importance_resampling(model::GenerativeFunction,
    model_args::Tuple, observations::ChoiceMap, num_samples::Int)

(traces, lml_est) = importance_resampling(model::GenerativeFunction,
    model_args::Tuple, observations::ChoiceMap,
    proposal::GenerativeFunction, proposal_args::Tuple,
    num_samples::Int)</code></pre><p>Run sampling importance resampling, returning a single trace.</p><p>Unlike <code>importance_sampling</code>, the memory used constant in the number of samples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/importance.jl#L51-L63">source</a></section><h2><a class="nav-anchor" id="Markov-Chain-Monte-Carlo-1" href="#Markov-Chain-Monte-Carlo-1">Markov Chain Monte Carlo</a></h2><p>The following inference library methods take a trace and return a new trace.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.metropolis_hastings" href="#Gen.metropolis_hastings"><code>Gen.metropolis_hastings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = metropolis_hastings(trace, selection::Selection)</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for the selected addresses from the internal proposal (often using ancestral sampling).</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/mh.jl#L1-L5">source</a><div><div><pre><code class="language-none">(new_trace, accepted) = metropolis_hastings(trace, proposal::GenerativeFunction, proposal_args::Tuple)</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for some subset of random choices in the given trace using the given proposal generative function.</p><p>The proposal generative function should take as its first argument the current trace of the model, and remaining arguments <code>proposal_args</code>. If the proposal modifies addresses that determine the control flow in the model, values must be provided by the proposal for any addresses that are newly sampled by the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/mh.jl#L20-L27">source</a><div><div><pre><code class="language-none">(new_trace, accepted) = metropolis_hastings(trace, proposal::GenerativeFunction, proposal_args::Tuple, involution::Function)</code></pre><p>Perform a generalized Metropolis-Hastings update based on an involution (bijection that is its own inverse) on a space of assignments.</p><p>The `involution&#39; Julia function has the following signature:</p><pre><code class="language-none">(new_trace, bwd_choices::ChoiceMap, weight) = involution(trace, fwd_choices::ChoiceMap, fwd_ret, proposal_args::Tuple)</code></pre><p>The generative function <code>proposal</code> is executed on arguments <code>(trace, proposal_args...)</code>, producing an assignment <code>fwd_choices</code> and return value <code>fwd_ret</code>. For each value of model arguments (contained in <code>trace</code>) and <code>proposal_args</code>, the <code>involution</code> function applies an involution that maps the tuple <code>(get_choices(trace), fwd_choices)</code> to the tuple <code>(get_choices(new_trace), bwd_choices)</code>. Note that <code>fwd_ret</code> is a deterministic function of <code>fwd_choices</code> and <code>proposal_args</code>. When only discrete random choices are used, the <code>weight</code> must be equal to <code>get_score(new_trace) - get_score(trace)</code>.</p><p><strong>Including Continuous Random Choices</strong> When continuous random choices are used, the <code>weight</code> must include an additive term that is the determinant of the the Jacobian of the bijection on the continuous random choices that is obtained by currying the involution on the discrete random choices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/mh.jl#L47-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.mh" href="#Gen.mh"><code>Gen.mh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = mh(trace, selection::Selection)
(new_trace, accepted) = mh(trace, proposal::GenerativeFunction, proposal_args::Tuple)
(new_trace, accepted) = mh(trace, proposal::GenerativeFunction, proposal_args::Tuple, involution::Function)</code></pre><p>Alias for <a href="#Gen.metropolis_hastings"><code>metropolis_hastings</code></a>. Perform a Metropolis-Hastings update on the given trace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/mh.jl#L99-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.mala" href="#Gen.mala"><code>Gen.mala</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = mala(trace, selection::Selection, tau::Real)</code></pre><p>Apply a Metropolis-Adjusted Langevin Algorithm (MALA) update.</p><p><a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm">Reference URL</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/mala.jl#L2-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.hmc" href="#Gen.hmc"><code>Gen.hmc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = hmc(trace, selection::Selection, mass=0.1, L=10, eps=0.1)</code></pre><p>Apply a Hamiltonian Monte Carlo (HMC) update.</p><p>Neal, Radford M. &quot;MCMC using Hamiltonian dynamics.&quot; Handbook of Markov Chain Monte Carlo 2.11 (2011): 2.</p><p><a href="http://www.mcmchandbook.net/HandbookChapter5.pdf">Reference URL</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/hmc.jl#L13-L21">source</a></section><h2><a class="nav-anchor" id="Optimization-over-Random-Choices-1" href="#Optimization-over-Random-Choices-1">Optimization over Random Choices</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.map_optimize" href="#Gen.map_optimize"><code>Gen.map_optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">new_trace = map_optimize(trace, selection::Selection, 
    max_step_size=0.1, tau=0.5, min_step_size=1e-16, verbose=false)</code></pre><p>Perform backtracking gradient ascent to optimize the log probability of the trace over selected continuous choices.</p><p>Selected random choices must have support on the entire real line.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/map_optimize.jl#L1-L8">source</a></section><h2><a class="nav-anchor" id="Particle-Filtering-1" href="#Particle-Filtering-1">Particle Filtering</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize_particle_filter" href="#Gen.initialize_particle_filter"><code>Gen.initialize_particle_filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">state = initialize_particle_filter(model::GenerativeFunction, model_args::Tuple,
    observations::ChoiceMap proposal::GenerativeFunction, proposal_args::Tuple,
    num_particles::Int)</code></pre><p>Initialize the state of a particle filter using a custom proposal for the initial latent state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L72-L78">source</a><div><div><pre><code class="language-none">state = initialize_particle_filter(model::GenerativeFunction, model_args::Tuple,
    observations::ChoiceMap, num_particles::Int)</code></pre><p>Initialize the state of a particle filter, using the default proposal for the initial latent state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L93-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.particle_filter_step!" href="#Gen.particle_filter_step!"><code>Gen.particle_filter_step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">particle_filter_step!(state::ParticleFilterState, new_args::Tuple, argdiffs,
    observations::ChoiceMap, proposal::GenerativeFunction, proposal_args::Tuple)</code></pre><p>Perform a particle filter update, where the model arguments are adjusted, new observations are added, and some combination of a custom proposal and the model&#39;s internal proposal is used for proposing new latent state (whatever is not proposed from the custom proposal will be proposed using the model&#39;s internal proposal).</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L110-L115">source</a><div><div><pre><code class="language-none">particle_filter_step!(state::ParticleFilterState, new_args::Tuple, argdiffs,
    observations::ChoiceMap)</code></pre><p>Perform a particle filter update, where the model arguments are adjusted, new observations are added, and the default proposal is used for new latent state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L135-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.maybe_resample!" href="#Gen.maybe_resample!"><code>Gen.maybe_resample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">did_resample::Bool = maybe_resample!(state::ParticleFilterState;
    ess_threshold::Float64=length(state.traces)/2, verbose=false)</code></pre><p>Do a resampling step if the effective sample size is below the given threshold.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L161-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.log_ml_estimate" href="#Gen.log_ml_estimate"><code>Gen.log_ml_estimate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">estimate = log_ml_estimate(state::ParticleFilterState)</code></pre><p>Return the particle filter&#39;s current estimate of the log marginal likelihood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L47-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_traces" href="#Gen.get_traces"><code>Gen.get_traces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">traces = get_traces(state::ParticleFilterState)</code></pre><p>Return the vector of traces in the current state, one for each particle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L26-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_log_weights" href="#Gen.get_log_weights"><code>Gen.get_log_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log_weights = get_log_weights(state::ParticleFilterState)</code></pre><p>Return the vector of log weights for the current state, one for each particle.</p><p>The weights are not normalized, and are in log-space.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L36-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.sample_unweighted_traces" href="#Gen.sample_unweighted_traces"><code>Gen.sample_unweighted_traces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">traces::Vector = sample_unweighted_traces(state::ParticleFilterState, num_samples::Int)</code></pre><p>Sample a vector of <code>num_samples</code> traces from the weighted collection of traces in the given particle filter state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/particle_filter.jl#L57-L61">source</a></section><h2><a class="nav-anchor" id="Supervised-Training-1" href="#Supervised-Training-1">Supervised Training</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.train!" href="#Gen.train!"><code>Gen.train!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">train!(gen_fn::GenerativeFunction, data_generator::Function,
       update::ParamUpdate,
       num_epoch, epoch_size, num_minibatch, minibatch_size; verbose::Bool=false)</code></pre><p>Train the given generative function to maximize the expected conditional log probability (density) that <code>gen_fn</code> generates the assignment <code>constraints</code> given inputs, where the expectation is taken under the output distribution of <code>data_generator</code>.</p><p>The function <code>data_generator</code> is a function of no arguments that returns a tuple <code>(inputs, constraints)</code> where <code>inputs</code> is a <code>Tuple</code> of inputs (arguments) to <code>gen_fn</code>, and <code>constraints</code> is an <code>ChoiceMap</code>. <code>conf</code> configures the optimization algorithm used. <code>param_lists</code> is a map from generative function to lists of its parameters. This is equivalent to minimizing the expected KL divergence from the conditional distribution <code>constraints | inputs</code> of the data generator to the distribution represented by the generative function, where the expectation is taken under the marginal distribution on <code>inputs</code> determined by the data generator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/train.jl#L1-L12">source</a></section><h2><a class="nav-anchor" id="Variational-Inference-1" href="#Variational-Inference-1">Variational Inference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.black_box_vi!" href="#Gen.black_box_vi!"><code>Gen.black_box_vi!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">black_box_vi!(model::GenerativeFunction, args::Tuple,
              observations::ChoiceMap,
              proposal::GenerativeFunction, proposal_args::Tuple,
              update::ParamUpdate;
              iters=1000, samples_per_iter=100, verbose=false)</code></pre><p>Fit the parameters of a generative function (<code>proposal</code>) to the posterior distribution implied by the given model and observations using stochastic gradient methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/d98bb2e17a769bb2b01e04d9132addc84fe88293/src/inference/variational.jl#L1-L9">source</a></section><footer><hr/><a class="previous" href="../parameter_optimization/"><span class="direction">Previous</span><span class="title">Optimizing Trainable Parameters</span></a><a class="next" href="../internals/parameter_optimization/"><span class="direction">Next</span><span class="title">Optimizing Trainable Parameters</span></a></footer></article></body></html>
