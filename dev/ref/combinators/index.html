<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Function Combinators · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><a class="toctext" href="../../guide/">Guide</a></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li class="current"><a class="toctext" href>Generative Function Combinators</a><ul class="internal"><li><a class="toctext" href="#Map-combinator-1">Map combinator</a></li><li><a class="toctext" href="#Unfold-combinator-1">Unfold combinator</a></li><li><a class="toctext" href="#Recurse-combinator-1">Recurse combinator</a></li></ul></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li><li><a class="toctext" href="../gfi/">Generative Function Interface</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Generative Function Combinators</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/combinators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Function Combinators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Function-Combinators-1" href="#Generative-Function-Combinators-1">Generative Function Combinators</a></h1><p>Generative function combinators are Julia functions that take one or more generative functions as input and return a new generative function. Generative function combinators are used to express patterns of repeated computation that appear frequently in generative models. Some generative function combinators are similar to higher order functions from functional programming languages. However, generative function combinators are not &#39;higher order generative functions&#39;, because they are not themselves generative functions (they are regular Julia functions).</p><h2><a class="nav-anchor" id="Map-combinator-1" href="#Map-combinator-1">Map combinator</a></h2><p>The <em>map</em> combinator takes a generative function as input, and returns a generative function that applies the given generative function independently to a vector of arguments. The returned generative function has one argument with type <code>Vector{T}</code> for each argument of type <code>T</code> of the input generative function. The length of each argument, which must be the same for each argument, determines the number of times the input generative function is called (N). Each call to the input function is made under address namespace i for i=1..N. The return value of the returned function has type <code>Vector{T}</code> where <code>T</code> is the type of the return value of the input function. The map combinator is similar to the &#39;map&#39; higher order function in functional programming, except that the map combinator returns a new generative function that must then be separately applied.</p><p>For example, consider the following generative function, which makes one random choice at address <code>:z</code>:</p><pre><code class="language-julia">@gen function foo(x::Float64, y::Float64)
    @addr(normal(x + y, 1.0), :z)
end</code></pre><p>We apply the map combinator to produce a new generative function <code>bar</code>:</p><pre><code class="language-julia">bar = Map(foo)</code></pre><p>We can then obtain a trace of <code>bar</code>:</p><pre><code class="language-julia">xs = [0.0, 0.5]
ys = [0.5, 1.0]
(trace, _) = initialize(bar, (xs, ys))</code></pre><p>This causes <code>foo</code> to be invoked twice, once with arguments <code>(xs[1], ys[1])</code> in address namespace <code>1</code> and once with arguments <code>(xs[2], ys[2])</code> in address namespace <code>2</code>. The resulting trace has random choices at addresses <code>1 =&gt; :z</code> and <code>2 =&gt; :z</code>.</p><h2><a class="nav-anchor" id="Unfold-combinator-1" href="#Unfold-combinator-1">Unfold combinator</a></h2><h2><a class="nav-anchor" id="Recurse-combinator-1" href="#Recurse-combinator-1">Recurse combinator</a></h2><footer><hr/><a class="previous" href="../modeling/"><span class="direction">Previous</span><span class="title">Built-in Modeling Language</span></a><a class="next" href="../assignments/"><span class="direction">Next</span><span class="title">Assignments</span></a></footer></article></body></html>
