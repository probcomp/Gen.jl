<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choice Maps · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Modeling Languages and APIs</span><ul><li><a class="toctext" href="../gfi/">Generative Functions</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li class="current"><a class="toctext" href>Choice Maps</a><ul class="internal"><li><a class="toctext" href="#Mutable-Choice-Maps-1">Mutable Choice Maps</a></li></ul></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../extending/">Extending Gen</a></li></ul></li><li><span class="toctext">Standard Inference Library</span><ul><li><a class="toctext" href="../importance/">Importance Sampling</a></li><li><a class="toctext" href="../mcmc/">Markov chain Monte Carlo</a></li><li><a class="toctext" href="../map/">MAP Optimization</a></li><li><a class="toctext" href="../pf/">Particle Filtering</a></li><li><a class="toctext" href="../vi/">Variational Inference</a></li><li><a class="toctext" href="../learning/">Learning Generative Functions</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../internals/language_implementation/">Modeling Language Implementation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modeling Languages and APIs</li><li><a href>Choice Maps</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen.jl/blob/master/docs/src/ref/choice_maps.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Choice Maps</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Choice-Maps-1" href="#Choice-Maps-1">Choice Maps</a></h1><p>Maps from the addresses of random choices to their values are stored in associative tree-structured data structures that have the following abstract type:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.ChoiceMap" href="#Gen.ChoiceMap"><code>Gen.ChoiceMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type ChoiceMap end</code></pre><p>Abstract type for maps from hierarchical addresses to values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L56-L60">source</a></section><p>Choice maps are constructed by users to express observations and/or constraints on the traces of generative functions. Choice maps are also returned by certain Gen inference methods, and are used internally by various Gen inference methods.</p><p>Choice maps provide the following methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_value" href="#Gen.has_value"><code>Gen.has_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_value(choices::ChoiceMap, addr)</code></pre><p>Return true if there is a value at the given address.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_value" href="#Gen.get_value"><code>Gen.get_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_value(choices::ChoiceMap, addr)</code></pre><p>Return the value at the given address in the assignment, or throw a KeyError if no value exists. A syntactic sugar is <code>Base.getindex</code>:</p><pre><code class="language-none">value = choices[addr]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L23-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_submap" href="#Gen.get_submap"><code>Gen.get_submap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">submap = get_submap(choices::ChoiceMap, addr)</code></pre><p>Return the sub-assignment containing all choices whose address is prefixed by addr.</p><p>It is an error if the assignment contains a value at the given address. If there are no choices whose address is prefixed by addr then return an <code>EmptyChoiceMap</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L12-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_values_shallow" href="#Gen.get_values_shallow"><code>Gen.get_values_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_submap_iterable = get_values_shallow(choices::ChoiceMap)</code></pre><p>Return an iterable collection of tuples <code>(key, value)</code> for each top-level key associated with a value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_submaps_shallow" href="#Gen.get_submaps_shallow"><code>Gen.get_submaps_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_submap_iterable = get_submaps_shallow(choices::ChoiceMap)</code></pre><p>Return an iterable collection of tuples <code>(key, submap::ChoiceMap)</code> for each top-level key that has a non-empty sub-assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L33-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.to_array" href="#Gen.to_array"><code>Gen.to_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arr::Vector{T} = to_array(choices::ChoiceMap, ::Type{T}) where {T}</code></pre><p>Populate an array with values of choices in the given assignment.</p><p>It is an error if each of the values cannot be coerced into a value of the given type.</p><p><strong>Implementation</strong></p><p>To support <code>to_array</code>, a concrete subtype <code>T &lt;: ChoiceMap</code> should implement the following method:</p><pre><code class="language-none">n::Int = _fill_array!(choices::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Populate <code>arr</code> with values from the given assignment, starting at <code>start_idx</code>, and return the number of elements in <code>arr</code> that were populated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L145-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.from_array" href="#Gen.from_array"><code>Gen.from_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">choices::ChoiceMap = from_array(proto_choices::ChoiceMap, arr::Vector)</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from the given array.</p><p>The order in which addresses are populated is determined by the prototype assignment. It is an error if the number of choices in the prototype assignment is not equal to the length the array.</p><p><strong>Implementation</strong></p><p>To support <code>from_array</code>, a concrete subtype <code>T &lt;: ChoiceMap</code> should implement the following method:</p><pre><code class="language-none">(n::Int, choices::T) = _from_array(proto_choices::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from <code>arr</code>, starting at position <code>start_idx</code>, and the number of elements read from <code>arr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L188-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_selected" href="#Gen.get_selected"><code>Gen.get_selected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selected_choices = get_selected(choices::ChoiceMap, selection::Selection)</code></pre><p>Filter the choice map to include only choices in the given selection.</p><p>Returns a new choice map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L991-L997">source</a></section><p>Note that none of these methods mutate the choice map.</p><p>Choice maps also implement:</p><ul><li><p><code>Base.isempty</code>, which tests of there are no random choices in the choice map</p></li><li><p><code>Base.merge</code>, which takes two choice maps, and returns a new choice map containing all random choices in either choice map. It is an error if the choice maps both have values at the same address, or if one choice map has a value at an address that is the prefix of the address of a value in the other choice map.</p></li><li><p><code>==</code>, which tests if two choice maps have the same addresses and values at those addresses.</p></li></ul><h2><a class="nav-anchor" id="Mutable-Choice-Maps-1" href="#Mutable-Choice-Maps-1">Mutable Choice Maps</a></h2><p>A mutable choice map can be constructed with <a href="#Gen.choicemap"><code>choicemap</code></a>, and then populated:</p><pre><code class="language-julia">choices = choicemap()
choices[:x] = true
choices[&quot;foo&quot;] = 1.25
choices[:y =&gt; 1 =&gt; :z] = -6.3</code></pre><p>There is also a constructor that takes initial (address, value) pairs:</p><pre><code class="language-julia">choices = choicemap((:x, true), (&quot;foo&quot;, 1.25), (:y =&gt; 1 =&gt; :z, -6.3))</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.choicemap" href="#Gen.choicemap"><code>Gen.choicemap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">choices = choicemap()</code></pre><p>Construct an empty mutable choice map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L654-L658">source</a><div><div><pre><code class="language-none">choices = choicemap(tuples...)</code></pre><p>Construct a mutable choice map initialized with given address, value tuples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L663-L667">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_value!" href="#Gen.set_value!"><code>Gen.set_value!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_value!(choices::DynamicChoiceMap, addr, value)</code></pre><p>Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at this address to be deleted. It is an error if there is already a value present at some prefix of the given address.</p><p>The following syntactic sugar is provided:</p><pre><code class="language-none">choices[addr] = value</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L704-L715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_submap!" href="#Gen.set_submap!"><code>Gen.set_submap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_submap!(choices::DynamicChoiceMap, addr, submap::ChoiceMap)</code></pre><p>Replace the sub-assignment rooted at the given address with the given sub-assignment. Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at the given address to be deleted. It is an error if there is already a value present at some prefix of address.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen.jl/blob/a2bf69b40b663297d48fbca136f00b634f0c7176/src/choice_map.jl#L738-L746">source</a></section><footer><hr/><a class="previous" href="../combinators/"><span class="direction">Previous</span><span class="title">Generative Function Combinators</span></a><a class="next" href="../selections/"><span class="direction">Next</span><span class="title">Selections</span></a></footer></article></body></html>
